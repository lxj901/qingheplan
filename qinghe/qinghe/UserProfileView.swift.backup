import SwiftUI

/// ç”¨æˆ·è¯¦æƒ…é¡µé¢ - æ¨ç‰¹é£æ ¼è®¾è®¡
struct UserProfileView: View {
    let userId: String
    @Environment(\.dismiss) private var dismiss
    @StateObject private var viewModel = UserProfileViewModel()
    @State private var selectedTab: ProfileTab = .posts
    @State private var scrollOffset: CGFloat = 0
    @State private var headerOffset: CGFloat = 0
    @State private var tabBarOffset: CGFloat = 0
    @State private var showNavTitle: Bool = false
    @State private var isAnimationEnabled: Bool = true
    @State private var lastScrollUpdate: Date = Date()
    @State private var scrollTimer: Timer?
    @State private var fallbackScrollOffset: CGFloat = 0

    // å…³æ³¨åˆ—è¡¨ç›¸å…³
    @State private var showFollowersList = false
    @State private var showFollowingList = false

    // æ›´å¤šé€‰é¡¹ç›¸å…³
    @State private var showMoreOptions = false
    @State private var showBlockConfirmation = false

    // ç¼–è¾‘èµ„æ–™ç›¸å…³
    @State private var showEditProfile = false

    // å¸–å­è¯¦æƒ…å¯¼èˆªç›¸å…³
    @State private var showingPostDetail = false
    @State private var selectedPostId: String?

    // é˜²æ­¢é‡å¤åŠ è½½
    @State private var isLoadingMore = false
    @State private var showingReportSheet = false
    @State private var reportingPostId: String?

    // æ¨ç‰¹é£æ ¼çš„æ ‡ç­¾é¡µ
    enum ProfileTab: String, CaseIterable {
        case posts = "å¸–å­"
        case media = "åª’ä½“"
        case likes = "æ”¶è—"
    }

    var body: some View {
        ZStack {
            if viewModel.isLoading && viewModel.userProfile == nil {
                loadingView
            } else if let userProfile = viewModel.userProfile {
                mainContentView(userProfile)
            } else {
                errorView
            }

            // é¡¶éƒ¨å¯¼èˆªæ  - å›ºå®šåœ¨é¡¶éƒ¨
            VStack(spacing: 0) {
                // å¯¼èˆªæ 
                customNavigationBar

                Spacer()
            }
        }
        .ignoresSafeArea(.all, edges: .top) // å¿½ç•¥é¡¶éƒ¨å®‰å…¨åŒºåŸŸ
        .ignoresSafeArea(.all, edges: .bottom) // å¿½ç•¥åº•éƒ¨å®‰å…¨åŒºåŸŸï¼Œç¡®ä¿å¡«å……æ•´ä¸ªå±å¹•
        .navigationBarHidden(true)
        .sheet(isPresented: $showFollowersList) {
            UserListView(userId: userId, listType: .followers)
        }
        .sheet(isPresented: $showFollowingList) {
            UserListView(userId: userId, listType: .following)
        }
        .sheet(isPresented: $showEditProfile) {
            if let userProfile = viewModel.userProfile {
                EditProfileView(userProfile: Binding(
                    get: { userProfile },
                    set: { newProfile in
                        viewModel.userProfile = newProfile
                    }
                ))
            }
        }
        .navigationDestination(isPresented: $showingPostDetail) {
            if let postId = selectedPostId {
                PostDetailView(postId: postId)
                    .navigationBarHidden(true)
                    .onAppear {
                        print("ğŸ” ç”¨æˆ·è¯¦æƒ…é¡µé¢ï¼šå¯¼èˆªåˆ°å¸–å­è¯¦æƒ…é¡µé¢ï¼Œå¸–å­ID: \(postId)")
                    }
            }
        }
        .sheet(isPresented: $showingReportSheet) {
            if let postId = reportingPostId {
                ReportPostView(postId: postId) { reason, description in
                    Task {
                        // TODO: å®ç°ä¸¾æŠ¥åŠŸèƒ½
                        print("ä¸¾æŠ¥å¸–å­: \(postId), åŸå› : \(reason), æè¿°: \(description)")
                    }
                }
            }
        }
        .actionSheet(isPresented: $showMoreOptions) {
            moreOptionsActionSheet
        }
        .alert("ç¡®è®¤å±è”½", isPresented: $showBlockConfirmation) {
            Button("å–æ¶ˆ", role: .cancel) { }
            Button("å±è”½", role: .destructive) {
                Task {
                    await viewModel.blockUser(reason: "ç”¨æˆ·ä¸¾æŠ¥")
                }
            }
        } message: {
            Text("å±è”½åå°†æ— æ³•çœ‹åˆ°è¯¥ç”¨æˆ·çš„å†…å®¹ï¼Œç¡®å®šè¦å±è”½å—ï¼Ÿ")
        }
        .overlay(
            // é”™è¯¯æç¤º Toast
            VStack {
                Spacer()

                if let errorMessage = viewModel.errorMessage {
                    HStack {
                        Image(systemName: "exclamationmark.triangle.fill")
                            .foregroundColor(.white)

                        Text(errorMessage)
                            .font(.subheadline)
                            .foregroundColor(.white)
                            .multilineTextAlignment(.leading)

                        Spacer()

                        Button("å…³é—­") {
                            viewModel.errorMessage = nil
                        }
                        .font(.subheadline)
                        .foregroundColor(.white)
                    }
                    .padding()
                    .background(Color.red)
                    .cornerRadius(12)
                    .padding(.horizontal, 16)
                    .padding(.bottom, 100)
                    .transition(.move(edge: .bottom).combined(with: .opacity))
                    .animation(.easeInOut(duration: 0.3), value: viewModel.errorMessage)
                }
            }
        )
        .onAppear {
            // æ£€æŸ¥ç³»ç»ŸåŠ¨ç”»è®¾ç½®
            checkSystemAnimationSettings()

            // å¯åŠ¨å¤‡ç”¨æ»šåŠ¨ç›‘å¬å®šæ—¶å™¨
            startFallbackScrollMonitoring()

            if viewModel.userProfile?.id != Int(userId) {
                Task {
                    await viewModel.loadUserProfile(userId: userId)
                }
            }
        }
        .onDisappear {
            // åœæ­¢å¤‡ç”¨æ»šåŠ¨ç›‘å¬å®šæ—¶å™¨
            stopFallbackScrollMonitoring()
        }
    }

    // MARK: - æ›´å¤šé€‰é¡¹èœå•
    private var moreOptionsActionSheet: ActionSheet {
        guard let userProfile = viewModel.userProfile else {
            return ActionSheet(title: Text("é€‰é¡¹"))
        }

        var buttons: [ActionSheet.Button] = []

        // å¦‚æœä¸æ˜¯è‡ªå·±
        if userProfile.isMe != true {
            // å±è”½/å–æ¶ˆå±è”½é€‰é¡¹
            if userProfile.isBlocked == true {
                buttons.append(.default(Text("å–æ¶ˆå±è”½")) {
                    Task {
                        await viewModel.unblockUser()
                    }
                })
            } else {
                buttons.append(.destructive(Text("å±è”½ç”¨æˆ·")) {
                    showBlockConfirmation = true
                })
            }

            // ä¸¾æŠ¥é€‰é¡¹
            buttons.append(.destructive(Text("ä¸¾æŠ¥ç”¨æˆ·")) {
                // TODO: å®ç°ä¸¾æŠ¥åŠŸèƒ½
            })
        }

        // åˆ†äº«é€‰é¡¹
        buttons.append(.default(Text("åˆ†äº«ç”¨æˆ·")) {
            // TODO: å®ç°åˆ†äº«åŠŸèƒ½
        })

        // å–æ¶ˆæŒ‰é’®
        buttons.append(.cancel())

        return ActionSheet(
            title: Text("æ›´å¤šé€‰é¡¹"),
            buttons: buttons
        )
    }

    // MARK: - è‡ªå®šä¹‰å¯¼èˆªæ 
    private var customNavigationBar: some View {
        GeometryReader { geometry in
            HStack {
                // è¿”å›æŒ‰é’®
                Button(action: {
                    dismiss()
                }) {
                    Image(systemName: "arrow.left")
                        .font(.system(size: 16, weight: .medium)) // å‡å°å›¾æ ‡å¤§å°
                        .foregroundColor(.primary)
                }
                .frame(width: 36, height: 36) // å‡å°æŒ‰é’®å¤§å°
                .background(
                    Circle()
                        .fill(Color(.systemBackground))
                        .shadow(color: .black.opacity(0.1), radius: 2, x: 0, y: 1)
                )

                Spacer()

                // ç”¨æˆ·åï¼ˆæ»šåŠ¨æ—¶æ˜¾ç¤ºï¼‰- æ¨ç‰¹é£æ ¼æ¸å…¥
                if showNavTitle {
                    Text(viewModel.userProfile?.nickname ?? "")
                        .font(.system(size: 17, weight: .semibold))
                        .foregroundColor(.primary)
                        .transition(.asymmetric(
                            insertion: .opacity.combined(with: .scale(scale: 0.95)).combined(with: .move(edge: .top)),
                            removal: .opacity.combined(with: .scale(scale: 0.95)).combined(with: .move(edge: .top))
                        ))
                        .animation(isAnimationEnabled ? .spring(response: 0.4, dampingFraction: 0.8, blendDuration: 0) : .none, value: showNavTitle)
                }

                Spacer()

                // æ›´å¤šé€‰é¡¹æŒ‰é’®
                Button(action: {
                    showMoreOptions = true
                }) {
                    Image(systemName: "ellipsis")
                        .font(.system(size: 16, weight: .medium)) // å‡å°å›¾æ ‡å¤§å°
                        .foregroundColor(.primary)
                }
                .frame(width: 36, height: 36) // å‡å°æŒ‰é’®å¤§å°
                .background(
                    Circle()
                        .fill(Color(.systemBackground))
                        .shadow(color: .black.opacity(0.1), radius: 2, x: 0, y: 1)
                )
            }
            .padding(.horizontal, 16)
            .padding(.top, geometry.safeAreaInsets.top + 55) // è°ƒæ•´åˆ°55pxçš„åç§»
            .padding(.bottom, 8)
            .frame(maxWidth: .infinity)
            .background(
                ZStack {
                    // æ¨ç‰¹é£æ ¼çš„æ¸å˜èƒŒæ™¯
                    let opacity = calculateNavBarOpacity()

                    // åŸºç¡€èƒŒæ™¯è‰²
                    Color(.systemBackground)
                        .opacity(opacity * 0.9)

                    // æ¯›ç»ç’ƒæè´¨æ•ˆæœ
                    Rectangle()
                        .fill(.regularMaterial)
                        .opacity(opacity)

                    // é¡¶éƒ¨è¾¹æ¡†çº¿ï¼ˆå½“å®Œå…¨æ˜¾ç¤ºæ—¶ï¼‰
                    VStack {
                        Spacer()
                        Rectangle()
                            .fill(Color(.separator))
                            .frame(height: 0.5)
                            .opacity(opacity > 0.8 ? (opacity - 0.8) / 0.2 : 0)
                    }
                }
            )
        }
        .frame(height: 147) // å¢åŠ å¯¼èˆªæ é«˜åº¦ä»¥é€‚åº”55pxçš„åç§»
    }

    // MARK: - è®¡ç®—å¯¼èˆªæ é€æ˜åº¦
    private func calculateNavBarOpacity() -> Double {
        // æ¨ç‰¹é£æ ¼çš„æ¸å˜é˜ˆå€¼
        // scrollOffset åœ¨é¡¶éƒ¨æ—¶ä¸º0ï¼Œå‘ä¸Šæ»šåŠ¨æ—¶å˜ä¸ºè´Ÿæ•°
        let startFadeThreshold: CGFloat = -20  // å¼€å§‹æ¸å˜çš„ä½ç½®
        let fullOpacityThreshold: CGFloat = -80  // å®Œå…¨ä¸é€æ˜çš„ä½ç½®
        let maxOpacity: Double = 0.95

        // åªæœ‰å½“å‘ä¸Šæ»šåŠ¨æ—¶æ‰æ˜¾ç¤ºå¯¼èˆªæ èƒŒæ™¯
        if scrollOffset >= startFadeThreshold {
            return 0.0  // åœ¨é¡¶éƒ¨æ—¶å®Œå…¨é€æ˜
        }

        // è®¡ç®—æ»šåŠ¨è¿›åº¦
        let scrollProgress = min(max((startFadeThreshold - scrollOffset) / (startFadeThreshold - fullOpacityThreshold), 0), 1)

        // ä½¿ç”¨ç¼“åŠ¨å‡½æ•°è®©æ¸å˜æ›´è‡ªç„¶
        let easedProgress = easeInOutCubic(scrollProgress)

        return easedProgress * maxOpacity
    }

    // MARK: - ç¼“åŠ¨å‡½æ•°
    private func easeInOutCubic(_ t: CGFloat) -> Double {
        let t = Double(t)
        return t < 0.5 ? 4 * t * t * t : 1 - pow(-2 * t + 2, 3) / 2
    }
    
    // MARK: - æ£€æŸ¥ç³»ç»ŸåŠ¨ç”»è®¾ç½®
    private func checkSystemAnimationSettings() {
        // æ£€æŸ¥ç³»ç»Ÿæ˜¯å¦å¯ç”¨äº†åŠ¨ç”»
        let animationsEnabled = !UIAccessibility.isReduceMotionEnabled

        DispatchQueue.main.async {
            isAnimationEnabled = animationsEnabled
        }
    }

    // MARK: - å¤‡ç”¨æ»šåŠ¨ç›‘å¬æœºåˆ¶
    private func startFallbackScrollMonitoring() {
        // å¦‚æœPreferenceKeyåœ¨çœŸæœºä¸Šä¸å·¥ä½œï¼Œä½¿ç”¨å®šæ—¶å™¨ä½œä¸ºå¤‡ç”¨æ–¹æ¡ˆ
        scrollTimer = Timer.scheduledTimer(withTimeInterval: 0.016, repeats: true) { _ in
            // æ£€æŸ¥æ˜¯å¦é•¿æ—¶é—´æ²¡æœ‰æ”¶åˆ°æ»šåŠ¨æ›´æ–°
            let timeSinceLastUpdate = Date().timeIntervalSince(lastScrollUpdate)

            if timeSinceLastUpdate > 0.1 { // å¦‚æœè¶…è¿‡100msæ²¡æœ‰æ›´æ–°
                // ä½¿ç”¨å¤‡ç”¨æ–¹æ³•æ£€æµ‹æ»šåŠ¨
                DispatchQueue.main.async {
                    // å¦‚æœé•¿æ—¶é—´æ²¡æœ‰æ”¶åˆ°æ»šåŠ¨æ›´æ–°ï¼Œå¯èƒ½PreferenceKeyæœ‰é—®é¢˜
                    // è¿™æ—¶æˆ‘ä»¬å¯ä»¥å°è¯•æ‰‹åŠ¨è§¦å‘ä¸€äº›UIæ›´æ–°
                    if timeSinceLastUpdate > 1.0 {
                        // è¶…è¿‡1ç§’æ²¡æœ‰æ›´æ–°ï¼Œå¯èƒ½éœ€è¦é‡ç½®çŠ¶æ€
                    }
                }
            }
        }
    }

    private func stopFallbackScrollMonitoring() {
        scrollTimer?.invalidate()
        scrollTimer = nil
    }
    


    // MARK: - åŠ è½½è§†å›¾
    private var loadingView: some View {
        VStack(spacing: 20) {
            ProgressView()
                .scaleEffect(1.5)
            Text("åŠ è½½ä¸­...")
                .font(.subheadline)
                .foregroundColor(.secondary)
        }
        .frame(maxWidth: .infinity, maxHeight: .infinity)
    }

    // MARK: - é”™è¯¯è§†å›¾
    private var errorView: some View {
        VStack(spacing: 20) {
            Image(systemName: "exclamationmark.triangle")
                .font(.system(size: 50))
                .foregroundColor(.orange)

            Text("åŠ è½½å¤±è´¥")
                .font(.headline)
                .fontWeight(.semibold)

            Text(viewModel.errorMessage ?? "è¯·æ£€æŸ¥ç½‘ç»œè¿æ¥åé‡è¯•")
                .font(.subheadline)
                .foregroundColor(.secondary)
                .multilineTextAlignment(.center)

            Button("é‡è¯•") {
                Task {
                    await viewModel.loadUserProfile(userId: userId)
                }
            }
            .padding(.horizontal, 24)
            .padding(.vertical, 12)
            .background(Color.blue)
            .foregroundColor(.white)
            .cornerRadius(25)
        }
        .padding()
        .frame(maxWidth: .infinity, maxHeight: .infinity)
    }

    // MARK: - ä¸»è¦å†…å®¹è§†å›¾
    private func mainContentView(_ userProfile: UserProfile) -> some View {
        GeometryReader { geometry in
            ZStack {
                // ä¸»è¦æ»šåŠ¨å†…å®¹
                ScrollViewReader { proxy in
                    ScrollView {
                    VStack(spacing: 0) {
                        // æ»šåŠ¨ç›‘å¬å™¨ - æ”¾åœ¨æœ€é¡¶éƒ¨ï¼Œç¡®ä¿å§‹ç»ˆå¯è§
                        GeometryReader { scrollGeometry in
                            let offset = scrollGeometry.frame(in: .named("scrollView")).minY
                            Color.clear
                                .preference(key: ScrollOffsetPreferenceKey.self, value: offset)
                                .onAppear {
                                    // å¼ºåˆ¶è§¦å‘åˆå§‹åç§»é‡
                                    DispatchQueue.main.async {
                                        scrollOffset = offset
                                    }
                                }
                        }
                        .frame(height: 0) // ä¸å ç”¨ç©ºé—´

                        // æ¨ªå¹…å’Œç”¨æˆ·ä¿¡æ¯åŒºåŸŸ
                        profileHeaderSection(userProfile)

                        // æ ‡ç­¾é¡µå¯¼èˆª - å½“ä¸éœ€è¦å›ºå®šæ—¶æ˜¾ç¤º
                        if !shouldShowStickyTabBar() {
                            profileTabsSection
                                .background(
                                    GeometryReader { tabGeometry in
                                        Color.clear
                                            .preference(key: TabBarOffsetPreferenceKey.self, value: tabGeometry.frame(in: .named("scrollView")).minY)
                                    }
                                )
                        } else {
                            // å ä½ç©ºé—´ï¼Œä¿æŒå¸ƒå±€ä¸€è‡´
                            Rectangle()
                                .fill(Color.clear)
                                .frame(height: 50) // æ ‡ç­¾æ çš„é«˜åº¦
                        }

                        // å†…å®¹åŒºåŸŸ - ç¡®ä¿å¡«å……å‰©ä½™ç©ºé—´
                        profileContentSection
                            .frame(minHeight: calculateMinContentHeight(geometry: geometry))
                    }
                    .frame(maxWidth: .infinity)
                }
                .coordinateSpace(name: "scrollView")
            .simultaneousGesture(
                // æ·»åŠ æ‹–æ‹½æ‰‹åŠ¿ä½œä¸ºå¤‡ç”¨æ»šåŠ¨ç›‘å¬
                DragGesture(minimumDistance: 0)
                    .onChanged { value in
                        // é€šè¿‡æ‹–æ‹½æ‰‹åŠ¿ä¹Ÿèƒ½ç›‘å¬åˆ°æ»šåŠ¨
                        let currentTime = Date()
                        lastScrollUpdate = currentTime

                        // ä½¿ç”¨æ‹–æ‹½æ‰‹åŠ¿çš„æ•°æ®æ¥æ›´æ–°æ»šåŠ¨åç§»
                        let newOffset = value.translation.height

                        // æ›´æ–°æ»šåŠ¨çŠ¶æ€
                        DispatchQueue.main.async {
                            scrollOffset = newOffset

                            // æ¨ç‰¹é£æ ¼çš„æ ‡é¢˜æ˜¾ç¤ºé€»è¾‘ - å½“å†…å®¹å‘ä¸Šæ»šåŠ¨æ—¶æ˜¾ç¤ºæ ‡é¢˜
                            let titleThreshold: CGFloat = -50  // å‘ä¸Šæ»šåŠ¨50pxåæ˜¾ç¤ºæ ‡é¢˜
                            let shouldShowTitle = newOffset < titleThreshold

                            if showNavTitle != shouldShowTitle {
                                if isAnimationEnabled {
                                    withAnimation(.spring(response: 0.4, dampingFraction: 0.8)) {
                                        showNavTitle = shouldShowTitle
                                    }
                                } else {
                                    showNavTitle = shouldShowTitle
                                }
                            }
                        }
                    }
            )

            // å›ºå®šæ ‡ç­¾æ  - å½“æ»šåŠ¨åˆ°æŒ‡å®šä½ç½®æ—¶æ˜¾ç¤ºåœ¨å¯¼èˆªæ ä¸‹æ–¹
            VStack(spacing: 0) {
                // å¯¼èˆªæ å ä½ç©ºé—´
                Rectangle()
                    .fill(Color.clear)
                    .frame(height: 147) // å¯¼èˆªæ é«˜åº¦ï¼ˆçŠ¶æ€æ  + å¯¼èˆªæ ï¼‰

                // å›ºå®šæ ‡ç­¾æ 
                if shouldShowStickyTabBar() {
                    stickyTabBarView
                        .transition(.move(edge: .top).combined(with: .opacity))
                        .animation(.easeInOut(duration: 0.25), value: shouldShowStickyTabBar())
                }

                Spacer()
            }
        }

        .onPreferenceChange(HeaderOffsetPreferenceKey.self) { value in
            withAnimation(.easeInOut(duration: 0.15)) {
                headerOffset = value
            }
        }
        .onPreferenceChange(ScrollOffsetPreferenceKey.self) { value in
            let newOffset = value
            let currentTime = Date()
            lastScrollUpdate = currentTime

            // å¼ºåˆ¶æ›´æ–°æ»šåŠ¨åç§»ï¼Œç¡®ä¿åœ¨çœŸæœºä¸Šä¹Ÿèƒ½æ­£å¸¸å·¥ä½œ
            DispatchQueue.main.async {
                scrollOffset = newOffset

                // æ¨ç‰¹é£æ ¼çš„æ ‡é¢˜æ˜¾ç¤ºé€»è¾‘ - å½“å†…å®¹å‘ä¸Šæ»šåŠ¨æ—¶æ˜¾ç¤ºæ ‡é¢˜
                let titleThreshold: CGFloat = -50  // å‘ä¸Šæ»šåŠ¨50pxåæ˜¾ç¤ºæ ‡é¢˜
                let shouldShowTitle = newOffset < titleThreshold

                if showNavTitle != shouldShowTitle {
                    if isAnimationEnabled {
                        withAnimation(.spring(response: 0.4, dampingFraction: 0.8)) {
                            showNavTitle = shouldShowTitle
                        }
                    } else {
                        showNavTitle = shouldShowTitle
                    }
                }
            }
        }
        .onPreferenceChange(TabBarOffsetPreferenceKey.self) { value in
            withAnimation(.easeInOut(duration: 0.15)) {
                tabBarOffset = value
            }
        }
    }

    // MARK: - è®¡ç®—æœ€å°å†…å®¹é«˜åº¦
    private func calculateMinContentHeight(geometry: GeometryProxy) -> CGFloat {
        // è®¡ç®—å·²ä½¿ç”¨çš„é«˜åº¦
        let navigationBarHeight: CGFloat = 147 // å¯¼èˆªæ é«˜åº¦
        let bannerHeight: CGFloat = 200 // æ¨ªå¹…é«˜åº¦
        let userInfoHeight: CGFloat = 200 // ç”¨æˆ·ä¿¡æ¯åŒºåŸŸä¼°è®¡é«˜åº¦
        let tabBarHeight: CGFloat = 50 // æ ‡ç­¾æ é«˜åº¦

        let usedHeight = bannerHeight + userInfoHeight + tabBarHeight
        let availableHeight = geometry.size.height - navigationBarHeight

        // ç¡®ä¿å†…å®¹åŒºåŸŸè‡³å°‘å¡«å……å‰©ä½™çš„å±å¹•ç©ºé—´
        return max(availableHeight - usedHeight, 300) // æœ€å°300pxé«˜åº¦
    }

    // MARK: - ç”¨æˆ·èµ„æ–™å¤´éƒ¨åŒºåŸŸ
    private func profileHeaderSection(_ userProfile: UserProfile) -> some View {
        VStack(spacing: 0) {
            // æ¨ªå¹…å›¾ç‰‡
            bannerImageView

            // ç”¨æˆ·ä¿¡æ¯åŒºåŸŸ
            userInfoSection(userProfile)
        }
    }

    // MARK: - æ¨ªå¹…å›¾ç‰‡
    private var bannerImageView: some View {
        GeometryReader { geometry in
            // æ¨ç‰¹é£æ ¼çš„è§†å·®æ•ˆæœ
            // scrollOffset åœ¨é¡¶éƒ¨ä¸º0ï¼Œå‘ä¸Šæ»šåŠ¨ä¸ºè´Ÿæ•°ï¼Œå‘ä¸‹æ»šåŠ¨ä¸ºæ­£æ•°
            let parallaxOffset = scrollOffset > 0 ? scrollOffset * 0.5 : 0  // å‘ä¸‹æ‹‰æ—¶å›¾ç‰‡å‘ä¸‹ç§»åŠ¨

            // è®¡ç®—ç¼©æ”¾æ•ˆæœ - å‘ä¸‹æ‹‰æ—¶è½»å¾®æ”¾å¤§
            let scaleEffect = scrollOffset > 0 ? 1 + (scrollOffset / 1000) : 1

            Rectangle()
                .fill(
                    LinearGradient(
                        gradient: Gradient(colors: [
                            Color.blue.opacity(0.7),
                            Color.purple.opacity(0.5),
                            Color.pink.opacity(0.3)
                        ]),
                        startPoint: .topLeading,
                        endPoint: .bottomTrailing
                    )
                )
                .overlay(
                    // å¯ä»¥åœ¨è¿™é‡Œæ·»åŠ å®é™…çš„æ¨ªå¹…å›¾ç‰‡
                    AsyncImage(url: URL(string: "")) { image in
                        image
                            .resizable()
                            .aspectRatio(contentMode: .fill)
                            .scaleEffect(scaleEffect)

                    } placeholder: {
                        EmptyView()
                    }
                )
                .scaleEffect(scaleEffect)
                .frame(
                    width: geometry.size.width,
                    height: max(200 + geometry.safeAreaInsets.top + parallaxOffset, 200 + geometry.safeAreaInsets.top)
                )
                .offset(y: -geometry.safeAreaInsets.top - parallaxOffset)
                .clipped()
                .animation(isAnimationEnabled ? .easeOut(duration: 0.08) : .none, value: scrollOffset)
        }
        .frame(height: 200) // å®é™…æ˜¾ç¤ºçš„æ¨ªå¹…é«˜åº¦
    }

    // MARK: - ç”¨æˆ·ä¿¡æ¯åŒºåŸŸ
    private func userInfoSection(_ userProfile: UserProfile) -> some View {
        VStack(alignment: .leading, spacing: 16) {
            // å¤´åƒè¡Œ
            HStack {
                // å¤´åƒ
                profileAvatarView(userProfile)

                Spacer()
            }
            .padding(.top, -40) // è®©å¤´åƒéƒ¨åˆ†è¦†ç›–æ¨ªå¹…

            // ç”¨æˆ·åå’Œæ“ä½œæŒ‰é’®è¡Œ
            HStack(alignment: .center) {
                // ç”¨æˆ·åå’Œè®¤è¯ä¿¡æ¯
                userNameSection(userProfile)

                Spacer()

                // æ“ä½œæŒ‰é’®
                actionButtonsView(userProfile, viewModel: viewModel)
            }

            // ä¸ªäººç®€ä»‹
            if let bio = userProfile.bio, !bio.isEmpty {
                Text(bio)
                    .font(.subheadline)
                    .foregroundColor(.primary)
                    .lineLimit(nil)
            }

            // ä½ç½®ä¿¡æ¯
            if let location = userProfile.location, !location.isEmpty {
                HStack(spacing: 4) {
                    Image(systemName: "location")
                        .font(.system(size: 12))
                        .foregroundColor(.secondary)

                    Text(location)
                        .font(.subheadline)
                        .foregroundColor(.secondary)
                }
            }

            // ç»Ÿè®¡æ•°æ®
            userStatsSection(userProfile)
        }
        .padding(.horizontal, 16)
        .padding(.bottom, 20)
        .background(Color(.systemBackground))
    }

    // MARK: - å¤´åƒè§†å›¾
    private func profileAvatarView(_ userProfile: UserProfile) -> some View {
        // è®¡ç®—å¤´åƒçš„ç¼©æ”¾æ•ˆæœ
        let avatarScale = calculateAvatarScale()

        return AsyncImage(url: URL(string: userProfile.avatar ?? "")) { image in
            image
                .resizable()
                .aspectRatio(contentMode: .fill)
        } placeholder: {
            Circle()
                .fill(Color.gray.opacity(0.3))
                .overlay(
                    Image(systemName: "person.fill")
                        .font(.system(size: 40))
                        .foregroundColor(.gray)
                )
        }
        .frame(width: 80, height: 80)
        .clipShape(Circle())
        .overlay(
            Circle()
                .stroke(Color(.systemBackground), lineWidth: 4)
        )
        .scaleEffect(avatarScale)
    }

    // MARK: - è®¡ç®—å¤´åƒç¼©æ”¾
    private func calculateAvatarScale() -> CGFloat {
        // å‘ä¸Šæ»šåŠ¨æ—¶å¤´åƒè½»å¾®ç¼©å°ï¼Œæ¨¡æ‹Ÿæ¨ç‰¹æ•ˆæœ
        let threshold: CGFloat = -100  // å‘ä¸Šæ»šåŠ¨100px
        let minScale: CGFloat = 0.85

        // åªæœ‰å‘ä¸Šæ»šåŠ¨æ—¶æ‰ç¼©æ”¾
        if scrollOffset >= 0 {
            return 1.0  // åœ¨é¡¶éƒ¨æ—¶ä¿æŒåŸå§‹å¤§å°
        }

        let progress = min(max(-scrollOffset / (-threshold), 0), 1)
        return 1 - (progress * (1 - minScale))
    }

    // MARK: - æ“ä½œæŒ‰é’®
    private func actionButtonsView(_ userProfile: UserProfile, viewModel: UserProfileViewModel) -> some View {
        HStack(spacing: 12) {
            // æ¶ˆæ¯æŒ‰é’®
            Button(action: {
                // å‘é€æ¶ˆæ¯
            }) {
                Image(systemName: "message")
                    .font(.system(size: 16, weight: .medium))
                    .foregroundColor(.primary)
            }
            .frame(width: 36, height: 36)
            .overlay(
                RoundedRectangle(cornerRadius: 18)
                    .stroke(Color(.systemGray4), lineWidth: 1)
            )

            // ç¼–è¾‘èµ„æ–™æŒ‰é’®ï¼ˆå¦‚æœæ˜¯è‡ªå·±ï¼‰
            if userProfile.isMe == true {
                Button(action: {
                    showEditProfile = true
                }) {
                    Text("ç¼–è¾‘èµ„æ–™")
                        .font(.system(size: 15, weight: .semibold))
                        .foregroundColor(.primary)
                }
                .frame(height: 36)
                .padding(.horizontal, 20)
                .background(Color.clear)
                .overlay(
                    RoundedRectangle(cornerRadius: 18)
                        .stroke(Color(.systemGray4), lineWidth: 1)
                )
                .cornerRadius(18)
            } else {
                // å…³æ³¨/å–æ¶ˆå…³æ³¨æŒ‰é’®ï¼ˆå¦‚æœä¸æ˜¯è‡ªå·±ï¼‰
                Button(action: {
                    Task {
                        if userProfile.isFollowing == true {
                            await viewModel.unfollowUser()
                        } else {
                            await viewModel.followUser()
                        }
                    }
                }) {
                    HStack(spacing: 6) {
                        if viewModel.isFollowActionLoading {
                            ProgressView()
                                .scaleEffect(0.8)
                                .progressViewStyle(CircularProgressViewStyle(tint: userProfile.isFollowing == true ? .primary : .white))
                        }

                        Text(userProfile.isFollowing == true ? "å·²å…³æ³¨" : "å…³æ³¨")
                            .font(.system(size: 15, weight: .semibold))
                            .foregroundColor(userProfile.isFollowing == true ? .primary : .white)
                    }
                }
                .frame(height: 36)
                .padding(.horizontal, 20)
                .background(
                    userProfile.isFollowing == true ?
                    Color.clear : Color.black
                )
                .overlay(
                    RoundedRectangle(cornerRadius: 18)
                        .stroke(
                            userProfile.isFollowing == true ?
                            Color(.systemGray4) : Color.clear,
                            lineWidth: 1
                        )
                )
                .cornerRadius(18)
                .disabled(viewModel.isFollowActionLoading || viewModel.isLoading)
            }
        }
    }

    // MARK: - ç”¨æˆ·ååŒºåŸŸ
    private func userNameSection(_ userProfile: UserProfile) -> some View {
        VStack(alignment: .leading, spacing: 4) {
            HStack(spacing: 8) {
                Text(userProfile.nickname)
                    .font(.title2)
                    .fontWeight(.bold)
                    .foregroundColor(.primary)

                if userProfile.isVerified == true {
                    Image(systemName: "checkmark.seal.fill")
                        .font(.system(size: 16))
                        .foregroundColor(.blue)
                }
            }

            Text("@user\(userProfile.id)")
                .font(.subheadline)
                .foregroundColor(.secondary)
        }
    }

    // MARK: - ç»Ÿè®¡æ•°æ®åŒºåŸŸ
    private func userStatsSection(_ userProfile: UserProfile) -> some View {
        HStack(spacing: 20) {
            // æ­£åœ¨å…³æ³¨
            Button(action: {
                showFollowingList = true
            }) {
                statItem(
                    count: userProfile.followingCount ?? 0,
                    label: "æ­£åœ¨å…³æ³¨"
                )
            }
            .buttonStyle(PlainButtonStyle())

            // å…³æ³¨è€…
            Button(action: {
                showFollowersList = true
            }) {
                statItem(
                    count: userProfile.followersCount ?? 0,
                    label: "å…³æ³¨è€…"
                )
            }
            .buttonStyle(PlainButtonStyle())

            // å¸–å­æ•°ï¼ˆä¸å¯ç‚¹å‡»ï¼‰
            if let postsCount = userProfile.postsCount {
                statItem(
                    count: postsCount,
                    label: "å¸–å­"
                )
            }
        }
    }

    // MARK: - ç»Ÿè®¡é¡¹ç›®
    private func statItem(count: Int, label: String) -> some View {
        HStack(spacing: 4) {
            Text("\(count)")
                .font(.subheadline)
                .fontWeight(.semibold)
                .foregroundColor(.primary)

            Text(label)
                .font(.subheadline)
                .foregroundColor(.secondary)
        }
    }

    // MARK: - æ ‡ç­¾é¡µå¯¼èˆª
    private var profileTabsSection: some View {
        HStack(spacing: 0) {
            ForEach(ProfileTab.allCases, id: \.self) { tab in
                Button(action: {
                    withAnimation(.easeInOut(duration: 0.2)) {
                        selectedTab = tab
                    }
                }) {
                    VStack(spacing: 8) {
                        Text(tab.rawValue)
                            .font(.system(size: 15, weight: .medium))
                            .foregroundColor(selectedTab == tab ? .primary : .secondary)

                        Rectangle()
                            .fill(selectedTab == tab ? Color.blue : Color.clear)
                            .frame(height: 2)
                    }
                }
                .frame(maxWidth: .infinity) // å‡åˆ†å®½åº¦
                .padding(.vertical, 12)
            }
        }
        .background(
            ZStack {
                // åŸºç¡€èƒŒæ™¯
                Color(.systemBackground)
                    .opacity(shouldShowTabBarShadow() ? calculateTabBarOpacity() : 1.0)

                // æ¨ç‰¹é£æ ¼çš„æ¯›ç»ç’ƒæ•ˆæœ
                if shouldShowTabBarShadow() {
                    Rectangle()
                        .fill(.regularMaterial)
                        .opacity(calculateTabBarOpacity() * 0.8)
                }
            }
            .animation(.easeInOut(duration: 0.15), value: shouldShowTabBarShadow())
        )
        .overlay(
            Rectangle()
                .fill(Color(.systemGray5))
                .frame(height: 0.5),
            alignment: .bottom
        )
        .shadow(
            color: shouldShowTabBarShadow() ? .black.opacity(0.1) : .clear,
            radius: shouldShowTabBarShadow() ? 4 : 0,
            x: 0,
            y: 2
        )
        .animation(.easeInOut(duration: 0.2), value: shouldShowTabBarShadow())
    }

    // MARK: - è®¡ç®—æ ‡ç­¾æ é˜´å½±æ˜¾ç¤º
    private func shouldShowTabBarShadow() -> Bool {
        // åŸºäºæ»šåŠ¨åç§»é‡åˆ¤æ–­æ˜¯å¦æ˜¾ç¤ºé˜´å½±
        // å½“å‘ä¸Šæ»šåŠ¨è¶…è¿‡ä¸€å®šè·ç¦»æ—¶æ˜¾ç¤ºé˜´å½±æ•ˆæœ
        let shadowThreshold: CGFloat = -200  // å‘ä¸Šæ»šåŠ¨200pxåæ˜¾ç¤ºé˜´å½±
        return scrollOffset < shadowThreshold
    }

    // MARK: - è®¡ç®—æ ‡ç­¾æ èƒŒæ™¯é€æ˜åº¦
    private func calculateTabBarOpacity() -> Double {
        // åŸºäºæ»šåŠ¨åç§»é‡è®¡ç®—é€æ˜åº¦
        let startThreshold: CGFloat = -150   // å¼€å§‹æ˜¾ç¤ºèƒŒæ™¯çš„ä½ç½®
        let fullOpacityThreshold: CGFloat = -250  // å®Œå…¨ä¸é€æ˜çš„ä½ç½®

        if scrollOffset >= startThreshold {
            return 0.0  // åœ¨é¡¶éƒ¨æ—¶å®Œå…¨é€æ˜
        }

        let progress = min(max((startThreshold - scrollOffset) / (startThreshold - fullOpacityThreshold), 0), 1)
        return Double(progress) * 0.95
    }

    // MARK: - åˆ¤æ–­æ˜¯å¦æ˜¾ç¤ºå›ºå®šæ ‡ç­¾æ 
    private func shouldShowStickyTabBar() -> Bool {
        // å½“æ»šåŠ¨åç§»è¾¾åˆ°çº¦-600æ—¶ï¼Œæ˜¾ç¤ºå›ºå®šæ ‡ç­¾æ 
        let stickyThreshold: CGFloat = -600
        return scrollOffset <= stickyThreshold
    }

    // MARK: - å›ºå®šæ ‡ç­¾æ è§†å›¾
    private var stickyTabBarView: some View {
        HStack(spacing: 0) {
            ForEach(ProfileTab.allCases, id: \.self) { tab in
                Button(action: {
                    withAnimation(.easeInOut(duration: 0.2)) {
                        selectedTab = tab
                    }
                }) {
                    VStack(spacing: 8) {
                        Text(tab.rawValue)
                            .font(.system(size: 15, weight: .medium))
                            .foregroundColor(selectedTab == tab ? .primary : .secondary)

                        Rectangle()
                            .fill(selectedTab == tab ? Color.blue : Color.clear)
                            .frame(height: 2)
                    }
                }
                .frame(maxWidth: .infinity) // å‡åˆ†å®½åº¦
                .padding(.vertical, 12)
            }
        }
        .background(
            Rectangle()
                .fill(.regularMaterial)
                .opacity(0.95)
        )
        .overlay(
            Rectangle()
                .fill(Color(.systemGray5))
                .frame(height: 0.5),
            alignment: .bottom
        )
        .shadow(color: .black.opacity(0.1), radius: 4, x: 0, y: 2)
    }



    // MARK: - å†…å®¹åŒºåŸŸ
    private var profileContentSection: some View {
        VStack(spacing: 0) {
            switch selectedTab {
            case .posts:
                postsContentView
            case .media:
                mediaContentView
            case .likes:
                likesContentView
            }
        }
        .frame(maxWidth: .infinity, maxHeight: .infinity)
    }

    // MARK: - å¸–å­å†…å®¹
    private var postsContentView: some View {
        VStack(spacing: 0) {
            if viewModel.isLoadingPosts && viewModel.userPosts.isEmpty {
                // é¦–æ¬¡åŠ è½½çŠ¶æ€
                VStack(spacing: 16) {
                    ProgressView()
                        .scaleEffect(1.2)
                    Text("åŠ è½½å¸–å­ä¸­...")
                        .font(.subheadline)
                        .foregroundColor(.secondary)
                }
                .frame(maxWidth: .infinity, maxHeight: .infinity)
                .frame(minHeight: 400)
            } else if viewModel.userPosts.isEmpty {
                // ç©ºçŠ¶æ€
                VStack(spacing: 16) {
                    Image(systemName: "doc.text")
                        .font(.system(size: 48))
                        .foregroundColor(.secondary)

                    Text("æš‚æ— å¸–å­")
                        .font(.headline)
                        .foregroundColor(.primary)

                    Text("è¯¥ç”¨æˆ·è¿˜æ²¡æœ‰å‘å¸ƒä»»ä½•å¸–å­")
                        .font(.subheadline)
                        .foregroundColor(.secondary)
                        .multilineTextAlignment(.center)
                }
                .frame(maxWidth: .infinity, maxHeight: .infinity)
                .frame(minHeight: 400)
            } else {
                // å¸–å­åˆ—è¡¨
                LazyVStack(spacing: 0) {
                    ForEach(viewModel.userPosts, id: \.id) { post in
                    NavigationLink(destination: PostDetailView(postId: post.id)
                        .navigationBarHidden(true)
                        .onAppear {
                            print("ğŸ” ç”¨æˆ·è¯¦æƒ…é¡µé¢ï¼šå¯¼èˆªåˆ°å¸–å­è¯¦æƒ…é¡µé¢ï¼Œå¸–å­ID: \(post.id)")
                        }
                    ) {
                        PostCardView(
                            post: post,
                            showHotBadge: false,
                            showEditButton: false,
                            onLike: {
                                Task {
                                    await toggleLikePost(post.id)
                                }
                            },
                            onBookmark: {
                                Task {
                                    await toggleBookmarkPost(post.id)
                                }
                            },
                            onShare: {
                                Task {
                                    await sharePost(post.id)
                                }
                            },
                            onReport: {
                                reportingPostId = post.id
                                showingReportSheet = true
                            },
                            onNavigateToDetail: { postId in
                                // NavigationLink å·²ç»å¤„ç†å¯¼èˆªï¼Œè¿™é‡Œä¸éœ€è¦åšä»»ä½•äº‹æƒ…
                            },
                            onNavigateToUserProfile: { author in
                                // åœ¨ç”¨æˆ·è¯¦æƒ…é¡µé¢ï¼Œä¸éœ€è¦è·³è½¬åˆ°è‡ªå·±
                            }
                        )
                    }
                    .buttonStyle(PlainButtonStyle()) // ç¡®ä¿NavigationLinkä¸å½±å“å†…éƒ¨æŒ‰é’®çš„æ ·å¼
                    .onAppear {
                        // å½“æ»šåŠ¨åˆ°å€’æ•°ç¬¬3ä¸ªå¸–å­æ—¶ï¼ŒåŠ è½½æ›´å¤š
                        if post.id == viewModel.userPosts.suffix(3).first?.id &&
                           viewModel.hasMorePosts &&
                           !viewModel.isLoadingPosts &&
                           !isLoadingMore {
                            isLoadingMore = true
                            Task {
                                await viewModel.loadMorePosts()
                                await MainActor.run {
                                    isLoadingMore = false
                                }
                            }
                        }
                    }
                    }

                    // åŠ è½½æ›´å¤šæŒ‡ç¤ºå™¨
                    if viewModel.isLoadingPosts {
                        HStack {
                            ProgressView()
                                .scaleEffect(0.8)
                            Text("åŠ è½½æ›´å¤š...")
                                .font(.caption)
                                .foregroundColor(.secondary)
                        }
                        .frame(height: 50)
                    } else if !viewModel.hasMorePosts && !viewModel.userPosts.isEmpty {
                        Text("æ²¡æœ‰æ›´å¤šå¸–å­äº†")
                            .font(.caption)
                            .foregroundColor(.secondary)
                            .frame(height: 50)
                    }
                }
            }
        }
        .frame(maxWidth: .infinity, maxHeight: .infinity)
        .onAppear {
            // é¦–æ¬¡åŠ è½½å¸–å­
            if viewModel.userPosts.isEmpty {
                Task {
                    await viewModel.loadUserPosts(userId: userId, refresh: true)
                }
            }
        }
    }

    // MARK: - å…¶ä»–æ ‡ç­¾é¡µå†…å®¹
    private var mediaContentView: some View {
        VStack(spacing: 16) {
            Image(systemName: "photo.on.rectangle")
                .font(.system(size: 48))
                .foregroundColor(.secondary)

            Text("åª’ä½“å†…å®¹")
                .font(.headline)
                .foregroundColor(.primary)

            Text("è¯¥åŠŸèƒ½æ­£åœ¨å¼€å‘ä¸­")
                .font(.subheadline)
                .foregroundColor(.secondary)
        }
        .frame(maxWidth: .infinity, maxHeight: .infinity)
        .frame(minHeight: 400)
    }

    private var likesContentView: some View {
        VStack(spacing: 0) {
            // æ£€æŸ¥æ˜¯å¦ä¸ºå½“å‰ç”¨æˆ·æœ¬äºº
            if viewModel.userProfile?.isMe != true {
                VStack(spacing: 16) {
                    Image(systemName: "lock")
                        .font(.system(size: 48))
                        .foregroundColor(.secondary)

                    Text("ç§å¯†å†…å®¹")
                        .font(.headline)
                        .foregroundColor(.primary)

                    Text("åªæœ‰æœ¬äººæ‰èƒ½æŸ¥çœ‹æ”¶è—å†…å®¹")
                        .font(.subheadline)
                        .foregroundColor(.secondary)
                        .multilineTextAlignment(.center)
                }
                .frame(maxWidth: .infinity, maxHeight: .infinity)
                .frame(minHeight: 400)
            } else if viewModel.isLoadingBookmarks && viewModel.bookmarkedPosts.isEmpty {
                // é¦–æ¬¡åŠ è½½çŠ¶æ€
                VStack(spacing: 16) {
                    ProgressView()
                        .scaleEffect(1.2)
                    Text("åŠ è½½æ”¶è—ä¸­...")
                        .font(.subheadline)
                        .foregroundColor(.secondary)
                }
                .frame(maxWidth: .infinity, maxHeight: .infinity)
                .frame(minHeight: 400)
            } else if viewModel.bookmarkedPosts.isEmpty {
                // ç©ºçŠ¶æ€
                VStack(spacing: 16) {
                    Image(systemName: "bookmark")
                        .font(.system(size: 48))
                        .foregroundColor(.secondary)

                    Text("æš‚æ— æ”¶è—")
                        .font(.headline)
                        .foregroundColor(.primary)

                    Text("ä½ è¿˜æ²¡æœ‰æ”¶è—ä»»ä½•å¸–å­")
                        .font(.subheadline)
                        .foregroundColor(.secondary)
                        .multilineTextAlignment(.center)
                }
                .frame(maxWidth: .infinity, maxHeight: .infinity)
                .frame(minHeight: 400)
            } else {
                // æ”¶è—åˆ—è¡¨
                LazyVStack(spacing: 0) {
                    ForEach(viewModel.bookmarkedPosts) { post in
                    NavigationLink(destination: PostDetailView(postId: post.id)
                        .navigationBarHidden(true)
                        .onAppear {
                            print("ğŸ” ç”¨æˆ·è¯¦æƒ…é¡µé¢ï¼šå¯¼èˆªåˆ°å¸–å­è¯¦æƒ…é¡µé¢ï¼Œå¸–å­ID: \(post.id)")
                        }
                    ) {
                        PostCardView(
                            post: post,
                            showHotBadge: false,
                            showEditButton: false,
                            onLike: {
                                Task {
                                    await toggleLikeBookmarkedPost(post.id)
                                }
                            },
                            onBookmark: {
                                Task {
                                    await toggleBookmarkBookmarkedPost(post.id)
                                }
                            },
                            onShare: {
                                Task {
                                    await shareBookmarkedPost(post.id)
                                }
                            },
                            onReport: {
                                reportingPostId = post.id
                                showingReportSheet = true
                            },
                            onNavigateToDetail: { postId in
                                // NavigationLink å·²ç»å¤„ç†å¯¼èˆªï¼Œè¿™é‡Œä¸éœ€è¦åšä»»ä½•äº‹æƒ…
                            },
                            onNavigateToUserProfile: { author in
                                // å¯ä»¥è·³è½¬åˆ°ä½œè€…çš„ç”¨æˆ·è¯¦æƒ…é¡µé¢
                            }
                        )
                    }
                    .buttonStyle(PlainButtonStyle()) // ç¡®ä¿NavigationLinkä¸å½±å“å†…éƒ¨æŒ‰é’®çš„æ ·å¼
                    .onAppear {
                        // å½“æ»šåŠ¨åˆ°å€’æ•°ç¬¬3ä¸ªæ”¶è—æ—¶ï¼ŒåŠ è½½æ›´å¤š
                        if post.id == viewModel.bookmarkedPosts.suffix(3).first?.id {
                            Task {
                                await viewModel.loadMoreBookmarks()
                            }
                        }
                    }
                    }

                    // åŠ è½½æ›´å¤šæŒ‡ç¤ºå™¨
                    if viewModel.isLoadingBookmarks {
                        HStack {
                            ProgressView()
                                .scaleEffect(0.8)
                            Text("åŠ è½½æ›´å¤š...")
                                .font(.caption)
                                .foregroundColor(.secondary)
                        }
                        .frame(height: 50)
                    } else if !viewModel.hasMoreBookmarks && !viewModel.bookmarkedPosts.isEmpty {
                        Text("æ²¡æœ‰æ›´å¤šæ”¶è—äº†")
                            .font(.caption)
                            .foregroundColor(.secondary)
                            .frame(height: 50)
                    }
                }
            }
        }
        .frame(maxWidth: .infinity, maxHeight: .infinity)
        .onAppear {
            // é¦–æ¬¡åŠ è½½æ”¶è—ï¼ˆä»…å½“ä¸ºæœ¬äººæ—¶ï¼‰
            if viewModel.userProfile?.isMe == true && viewModel.bookmarkedPosts.isEmpty {
                Task {
                    await viewModel.loadUserBookmarks(refresh: true)
                }
            }
        }
    }
}







// MARK: - PreferenceKey å®šä¹‰
struct HeaderOffsetPreferenceKey: PreferenceKey {
    static var defaultValue: CGFloat = 0
    static func reduce(value: inout CGFloat, nextValue: () -> CGFloat) {
        value = nextValue()
    }
}

struct TabBarOffsetPreferenceKey: PreferenceKey {
    static var defaultValue: CGFloat = 0
    static func reduce(value: inout CGFloat, nextValue: () -> CGFloat) {
        value = nextValue()
    }
}

// MARK: - UserProfileView æ‰©å±• - å¸–å­äº¤äº’åŠŸèƒ½
extension UserProfileView {
    // MARK: - å¸–å­äº¤äº’åŠŸèƒ½
    private func toggleLikePost(_ postId: String) async {
        guard let index = viewModel.userPosts.firstIndex(where: { $0.id == postId }) else { return }

        do {
            let result = try await CommunityAPIService.shared.toggleLike(postId: postId)
            await MainActor.run {
                viewModel.userPosts[index].isLiked = result.isLiked

                if result.isLiked {
                    viewModel.userPosts[index].likesCount += 1
                } else {
                    viewModel.userPosts[index].likesCount = max(0, viewModel.userPosts[index].likesCount - 1)
                }
            }
        } catch {
            print("ç‚¹èµå¤±è´¥ï¼š\(error)")
        }
    }

    private func toggleBookmarkPost(_ postId: String) async {
        guard let index = viewModel.userPosts.firstIndex(where: { $0.id == postId }) else { return }

        do {
            let result = try await CommunityAPIService.shared.toggleBookmark(postId: postId)
            await MainActor.run {
                viewModel.userPosts[index].isBookmarked = result.isBookmarked

                if result.isBookmarked {
                    viewModel.userPosts[index].bookmarksCount += 1
                } else {
                    viewModel.userPosts[index].bookmarksCount = max(0, viewModel.userPosts[index].bookmarksCount - 1)
                }
            }
        } catch {
            print("æ”¶è—å¤±è´¥ï¼š\(error)")
        }
    }

    private func sharePost(_ postId: String) async {
        do {
            let _ = try await CommunityAPIService.shared.sharePost(postId: postId)
            print("åˆ†äº«æˆåŠŸ")
        } catch {
            print("åˆ†äº«å¤±è´¥ï¼š\(error)")
        }
    }

    // MARK: - æ”¶è—åˆ—è¡¨äº¤äº’åŠŸèƒ½
    private func toggleLikeBookmarkedPost(_ postId: String) async {
        guard let index = viewModel.bookmarkedPosts.firstIndex(where: { $0.id == postId }) else { return }

        do {
            let result = try await CommunityAPIService.shared.toggleLike(postId: postId)
            await MainActor.run {
                viewModel.bookmarkedPosts[index].isLiked = result.isLiked

                if result.isLiked {
                    viewModel.bookmarkedPosts[index].likesCount += 1
                } else {
                    viewModel.bookmarkedPosts[index].likesCount = max(0, viewModel.bookmarkedPosts[index].likesCount - 1)
                }
            }
        } catch {
            print("ç‚¹èµå¤±è´¥ï¼š\(error)")
        }
    }

    private func toggleBookmarkBookmarkedPost(_ postId: String) async {
        guard let index = viewModel.bookmarkedPosts.firstIndex(where: { $0.id == postId }) else { return }

        do {
            let result = try await CommunityAPIService.shared.toggleBookmark(postId: postId)
            await MainActor.run {
                viewModel.bookmarkedPosts[index].isBookmarked = result.isBookmarked

                if result.isBookmarked {
                    viewModel.bookmarkedPosts[index].bookmarksCount += 1
                } else {
                    viewModel.bookmarkedPosts[index].bookmarksCount = max(0, viewModel.bookmarkedPosts[index].bookmarksCount - 1)
                    // å¦‚æœå–æ¶ˆæ”¶è—ï¼Œä»æ”¶è—åˆ—è¡¨ä¸­ç§»é™¤
                    viewModel.bookmarkedPosts.remove(at: index)
                }
            }
        } catch {
            print("æ”¶è—å¤±è´¥ï¼š\(error)")
        }
    }

    private func shareBookmarkedPost(_ postId: String) async {
        do {
            let _ = try await CommunityAPIService.shared.sharePost(postId: postId)
            print("åˆ†äº«æˆåŠŸ")
        } catch {
            print("åˆ†äº«å¤±è´¥ï¼š\(error)")
        }
    }
}

// MARK: - é¢„è§ˆ
struct UserProfileView_Previews: PreviewProvider {
    static var previews: some View {
        UserProfileView(userId: "123")
    }
}
