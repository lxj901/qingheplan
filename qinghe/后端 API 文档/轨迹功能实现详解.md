# ğŸ—ºï¸ è½¨è¿¹åŠŸèƒ½å®ç°è¯¦è§£

## ğŸ“‹ æ¦‚è¿°

æœ¬æ–‡æ¡£è¯¦ç»†ä»‹ç»äº†é’ç¦¾è®¡åˆ’è¿åŠ¨åº”ç”¨ä¸­è½¨è¿¹åŠŸèƒ½çš„å®Œæ•´æŠ€æœ¯å®ç°ï¼ŒåŒ…æ‹¬GPSå®šä½ã€è½¨è¿¹è¿½è¸ªã€åæ ‡è½¬æ¢ã€æ•°æ®å¤„ç†ã€å¯è§†åŒ–æ¸²æŸ“ç­‰æ ¸å¿ƒæŠ€æœ¯ã€‚

## ğŸ—ï¸ æŠ€æœ¯æ¶æ„

### æ ¸å¿ƒç»„ä»¶
- **AppleMapService**: GPSå®šä½ä¸è½¨è¿¹è¿½è¸ªæ ¸å¿ƒæœåŠ¡
- **CoordinateConverter**: åæ ‡ç³»è½¬æ¢å·¥å…·
- **RoutePoint**: è½¨è¿¹ç‚¹æ•°æ®æ¨¡å‹
- **AppleMapView**: è½¨è¿¹å¯è§†åŒ–ç»„ä»¶

## ğŸ“ 1. GPSå®šä½ä¸è½¨è¿¹è¿½è¸ªæ ¸å¿ƒ

### 1.1 å®šä½æœåŠ¡é…ç½®

```swift
class AppleMapService: NSObject, ObservableObject, CLLocationManagerDelegate {
    private let locationManager = CLLocationManager()
    
    // é«˜ç²¾åº¦GPSé…ç½®
    private func setupLocationManager() {
        locationManager.delegate = self
        locationManager.desiredAccuracy = kCLLocationAccuracyBestForNavigation  // å¯¼èˆªçº§ç²¾åº¦
        locationManager.distanceFilter = 1.0  // 1ç±³æ›´æ–°ä¸€æ¬¡
        locationManager.activityType = .fitness  // è¿åŠ¨æ¨¡å¼
        locationManager.allowsBackgroundLocationUpdates = true  // åå°å®šä½
    }
    
    // è½¨è¿¹æ•°æ®å­˜å‚¨
    @Published var routePoints: [RoutePoint] = []
    @Published var currentLocation: CLLocation?
    @Published var isTracking: Bool = false
}
```

### 1.2 å®šä½æƒé™ç®¡ç†

```swift
func requestLocationPermission() {
    switch locationManager.authorizationStatus {
    case .notDetermined:
        locationManager.requestWhenInUseAuthorization()
    case .denied, .restricted:
        // å¼•å¯¼ç”¨æˆ·åˆ°è®¾ç½®é¡µé¢
        showLocationPermissionAlert()
    case .authorizedWhenInUse:
        locationManager.requestAlwaysAuthorization()  // è¯·æ±‚åå°æƒé™
    case .authorizedAlways:
        startLocationUpdates()
    @unknown default:
        break
    }
}
```

## ğŸ›¤ï¸ 2. è½¨è¿¹ç‚¹æ•°æ®ç»“æ„

### 2.1 RoutePoint æ•°æ®æ¨¡å‹

```swift
struct RoutePoint: Identifiable, Codable {
    let id = UUID()
    let latitude: Double      // çº¬åº¦
    let longitude: Double     // ç»åº¦
    let altitude: Double?     // æµ·æ‹”
    let timestamp: Date       // æ—¶é—´æˆ³
    let speed: Double?        // é€Ÿåº¦ (m/s)
    let course: Double        // æ–¹å‘è§’ (åº¦)
    let horizontalAccuracy: Double  // æ°´å¹³ç²¾åº¦
    
    var coordinate: CLLocationCoordinate2D {
        return CLLocationCoordinate2D(latitude: latitude, longitude: longitude)
    }
    
    // è®¡ç®—ä¸å¦ä¸€ç‚¹çš„è·ç¦»
    func distance(to point: RoutePoint) -> Double {
        let location1 = CLLocation(latitude: latitude, longitude: longitude)
        let location2 = CLLocation(latitude: point.latitude, longitude: point.longitude)
        return location1.distance(from: location2)
    }
}
```

### 2.2 è½¨è¿¹æ•°æ®é›†åˆ

```swift
struct WorkoutRoute: Codable {
    let id = UUID()
    let workoutType: WorkoutType
    let startTime: Date
    let endTime: Date
    let routePoints: [RoutePoint]
    let totalDistance: Double
    let averageSpeed: Double
    let maxSpeed: Double
    
    // è®¡ç®—è½¨è¿¹ç»Ÿè®¡ä¿¡æ¯
    var statistics: RouteStatistics {
        return RouteStatistics(from: routePoints)
    }
}
```

## ğŸ”„ 3. åæ ‡ç³»è½¬æ¢æŠ€æœ¯

### 3.1 åæ ‡ç³»è¯´æ˜

ä¸­å›½åœ°åŒºGPSå®šä½å­˜åœ¨åç§»é—®é¢˜ï¼Œéœ€è¦è¿›è¡Œåæ ‡ç³»è½¬æ¢ï¼š
- **WGS84**: GPSåŸå§‹åæ ‡ç³»ï¼ˆå›½é™…æ ‡å‡†ï¼‰
- **GCJ02**: ç«æ˜Ÿåæ ‡ç³»ï¼ˆä¸­å›½æ ‡å‡†ï¼Œé«˜å¾·/è…¾è®¯åœ°å›¾ä½¿ç”¨ï¼‰
- **BD09**: ç™¾åº¦åæ ‡ç³»ï¼ˆç™¾åº¦åœ°å›¾ä¸“ç”¨ï¼‰

### 3.2 åæ ‡è½¬æ¢å®ç°

```swift
class CoordinateConverter {
    // WGS84è½¬GCJ02ï¼ˆç«æ˜Ÿåæ ‡ç³»ï¼‰
    static func wgs84ToGcj02(_ wgs84: CLLocationCoordinate2D) -> CLLocationCoordinate2D {
        if isOutOfChina(wgs84) {
            return wgs84  // æµ·å¤–åœ°åŒºä¸éœ€è¦è½¬æ¢
        }
        
        var dLat = transformLat(wgs84.longitude - 105.0, wgs84.latitude - 35.0)
        var dLon = transformLon(wgs84.longitude - 105.0, wgs84.latitude - 35.0)
        
        let radLat = wgs84.latitude / 180.0 * Double.pi
        var magic = sin(radLat)
        magic = 1 - ee * magic * magic
        let sqrtMagic = sqrt(magic)
        
        dLat = (dLat * 180.0) / ((a * (1 - ee)) / (magic * sqrtMagic) * Double.pi)
        dLon = (dLon * 180.0) / (a / sqrtMagic * cos(radLat) * Double.pi)
        
        return CLLocationCoordinate2D(
            latitude: wgs84.latitude + dLat,
            longitude: wgs84.longitude + dLon
        )
    }
    
    // åˆ¤æ–­æ˜¯å¦åœ¨ä¸­å›½å¢ƒå†…
    private static func isOutOfChina(_ coord: CLLocationCoordinate2D) -> Bool {
        return coord.longitude < 72.004 || coord.longitude > 137.8347 ||
               coord.latitude < 0.8293 || coord.latitude > 55.8271
    }
}
```

### 3.3 å®æ—¶åæ ‡è½¬æ¢

```swift
private func processLocationUpdate(_ location: CLLocation) {
    // éªŒè¯åæ ‡æœ‰æ•ˆæ€§
    guard location.coordinate.isValid else {
        print("âš ï¸ æ— æ•ˆåæ ‡è¢«è¿‡æ»¤: \(location.coordinate)")
        return
    }
    
    // WGS84 â†’ GCJ02 åæ ‡è½¬æ¢
    let convertedLocation = location.convertedForChineseMap()
    
    let routePoint = RoutePoint(
        latitude: convertedLocation.coordinate.latitude,
        longitude: convertedLocation.coordinate.longitude,
        timestamp: location.timestamp,
        altitude: location.altitude,
        speed: max(0, location.speed),
        course: location.course >= 0 ? location.course : 0,
        horizontalAccuracy: location.horizontalAccuracy
    )
    
    routePoints.append(routePoint)
    
    print("ğŸ›¤ï¸ è½¨è¿¹ç‚¹åæ ‡è½¬æ¢:")
    print("   åŸå§‹åæ ‡: \(String(format: "%.8f, %.8f", location.coordinate.latitude, location.coordinate.longitude))")
    print("   è½¬æ¢åæ ‡: \(String(format: "%.8f, %.8f", convertedLocation.coordinate.latitude, convertedLocation.coordinate.longitude))")
}
```

## ğŸ“Š 4. å®æ—¶è½¨è¿¹æ•°æ®è®¡ç®—

### 4.1 è·ç¦»è®¡ç®—

```swift
private func updateMapBasedDistance(for location: CLLocation) {
    if let lastLoc = lastLocation {
        let distance = location.distance(from: lastLoc)
        
        // å¼‚å¸¸å€¼è¿‡æ»¤ - é˜²æ­¢GPSè·³è·ƒ
        let maxReasonableDistance = 100.0  // 100ç±³/ç§’æœ€å¤§åˆç†è·ç¦»
        let timeDiff = location.timestamp.timeIntervalSince(lastLoc.timestamp)
        
        if distance <= maxReasonableDistance && timeDiff > 0.5 {
            mapBasedDistance += distance
            print("âœ… è·ç¦»æ›´æ–°: +\(String(format: "%.1f", distance))m, æ€»è®¡: \(String(format: "%.1f", mapBasedDistance))m")
        } else {
            print("âš ï¸ è¿‡æ»¤å¼‚å¸¸è·ç¦»: \(String(format: "%.1f", distance))m")
        }
    }
    
    lastLocation = location
}
```

### 4.2 é€Ÿåº¦è®¡ç®—ä¸è¿‡æ»¤

```swift
private func calculateSpeed(from location: CLLocation) {
    if let lastLoc = lastLocation {
        let distance = location.distance(from: lastLoc)
        let timeDiff = location.timestamp.timeIntervalSince(lastLoc.timestamp)
        
        // æœ€å°æ—¶é—´å’Œè·ç¦»é˜ˆå€¼
        let minTimeDiff = 0.5  // æœ€å°0.5ç§’
        let minDistance = 1.0  // æœ€å°1ç±³
        
        if timeDiff >= minTimeDiff && distance >= minDistance {
            let calculatedSpeed = distance / timeDiff
            let maxReasonableSpeed = 13.9  // 50km/hä¸Šé™ (13.9 m/s)
            
            if calculatedSpeed <= maxReasonableSpeed && calculatedSpeed.isFinite {
                currentSpeed = calculatedSpeed
                speedReadings.append(calculatedSpeed)
                maxSpeed = max(maxSpeed, calculatedSpeed)
                
                // è®¡ç®—å¹³å‡é€Ÿåº¦
                averageSpeed = speedReadings.reduce(0, +) / Double(speedReadings.count)
                
                print("âœ… é€Ÿåº¦æ›´æ–°: \(String(format: "%.2f", calculatedSpeed)) m/s (\(String(format: "%.1f", calculatedSpeed * 3.6)) km/h)")
            } else {
                print("âš ï¸ è¿‡æ»¤å¼‚å¸¸é€Ÿåº¦: \(String(format: "%.2f", calculatedSpeed)) m/s")
            }
        }
    }
}
```

### 4.3 é…é€Ÿè®¡ç®—

```swift
// è·å–å½“å‰é…é€Ÿï¼ˆåˆ†é’Ÿ/å…¬é‡Œï¼‰
func getCurrentPace() -> Double {
    guard currentSpeed > 0 && currentSpeed.isFinite else { return 0 }
    let pace = 1000 / (currentSpeed * 60)  // è½¬æ¢ä¸ºåˆ†é’Ÿ/å…¬é‡Œ
    return pace.isFinite ? pace : 0
}

// è·å–å¹³å‡é…é€Ÿï¼ˆåˆ†é’Ÿ/å…¬é‡Œï¼‰
func getAveragePace() -> Double {
    guard averageSpeed > 0 && averageSpeed.isFinite else { return 0 }
    let pace = 1000 / (averageSpeed * 60)
    return pace.isFinite ? pace : 0
}
```

## ğŸ—ºï¸ 5. è½¨è¿¹å¯è§†åŒ–æ¸²æŸ“

### 5.1 åœ°å›¾è½¨è¿¹ç»˜åˆ¶

```swift
func updateRoute(with routePoints: [RoutePoint], on mapView: MKMapView) {
    // æ¸…é™¤æ—§è½¨è¿¹
    if let oldOverlay = routeOverlay {
        mapView.removeOverlay(oldOverlay)
    }
    
    // ç»˜åˆ¶æ–°è½¨è¿¹
    if routePoints.count >= 2 {
        let coordinates = routePoints.map { 
            CLLocationCoordinate2D(latitude: $0.latitude, longitude: $0.longitude) 
        }
        
        let polyline = MKPolyline(coordinates: coordinates, count: coordinates.count)
        polyline.title = "workout_route"  // æ ‡è¯†è½¨è¿¹ç±»å‹
        
        mapView.addOverlay(polyline)
        routeOverlay = polyline
        
        // è‡ªåŠ¨è°ƒæ•´åœ°å›¾è§†é‡ä»¥æ˜¾ç¤ºå®Œæ•´è½¨è¿¹
        if let region = calculateRouteRegion(from: coordinates) {
            mapView.setRegion(region, animated: true)
        }
    }
}
```

### 5.2 è½¨è¿¹æ ·å¼å®šåˆ¶

```swift
func mapView(_ mapView: MKMapView, rendererFor overlay: MKOverlay) -> MKOverlayRenderer {
    if let polyline = overlay as? MKPolyline {
        let renderer = MKPolylineRenderer(polyline: polyline)
        
        // æ ¹æ®è¿åŠ¨ç±»å‹è®¾ç½®ä¸åŒé¢œè‰²
        switch workoutType {
        case .running:
            renderer.strokeColor = UIColor.systemBlue
        case .cycling:
            renderer.strokeColor = UIColor.systemGreen
        case .walking:
            renderer.strokeColor = UIColor.systemOrange
        default:
            renderer.strokeColor = UIColor.systemPurple
        }
        
        renderer.lineWidth = 4.0
        renderer.lineCap = .round
        renderer.lineJoin = .round
        
        return renderer
    }
    
    return MKOverlayRenderer(overlay: overlay)
}
```

## ğŸ¯ 6. è½¨è¿¹ä¼˜åŒ–æŠ€æœ¯

### 6.1 å†…å­˜ç®¡ç†

```swift
// è½¨è¿¹ç‚¹æ•°é‡æ§åˆ¶
func trimLocationHistory() {
    let maxPoints = 5000  // æœ€å¤§ä¿ç•™5000ä¸ªç‚¹
    let maxSpeedReadings = 500  // æœ€å¤§ä¿ç•™500ä¸ªé€Ÿåº¦è®°å½•
    
    if routePoints.count > maxPoints {
        let pointsToRemove = routePoints.count - maxPoints
        routePoints.removeFirst(pointsToRemove)  // ä¿ç•™æœ€æ–°è½¨è¿¹
        print("ğŸ§¹ æ¸…ç†äº† \(pointsToRemove) ä¸ªå†å²ä½ç½®ç‚¹")
    }
    
    if speedReadings.count > maxSpeedReadings {
        let speedPointsToRemove = speedReadings.count - maxSpeedReadings
        speedReadings.removeFirst(speedPointsToRemove)
        print("ğŸ§¹ æ¸…ç†äº† \(speedPointsToRemove) ä¸ªå†å²é€Ÿåº¦è®°å½•")
    }
}
```

### 6.2 å†…å­˜è­¦å‘Šå¤„ç†

```swift
func handleMemoryWarning() {
    print("âš ï¸ æ”¶åˆ°å†…å­˜è­¦å‘Šï¼Œå¼€å§‹æ¸…ç†è½¨è¿¹ç¼“å­˜")
    
    // æ›´æ¿€è¿›çš„æ¸…ç†ç­–ç•¥
    let currentCount = routePoints.count
    if currentCount > 1000 {
        let pointsToKeep = 1000
        let pointsToRemove = currentCount - pointsToKeep
        routePoints.removeFirst(pointsToRemove)
        print("ğŸ§¹ å†…å­˜æ¸…ç†ï¼šä¿ç•™æœ€è¿‘ \(pointsToKeep) ä¸ªä½ç½®ç‚¹")
    }
    
    // æ¸…ç†é€Ÿåº¦è®°å½•
    if speedReadings.count > 100 {
        speedReadings.removeFirst(speedReadings.count - 100)
    }
    
    // å¼ºåˆ¶åƒåœ¾å›æ”¶
    DispatchQueue.global(qos: .utility).async {
        autoreleasepool {
            // è§¦å‘è‡ªåŠ¨é‡Šæ”¾æ± æ¸…ç†
        }
    }
}
```

### 6.3 å¼‚å¸¸æ•°æ®è¿‡æ»¤

```swift
private func isValidLocationUpdate(_ location: CLLocation) -> Bool {
    // åæ ‡æœ‰æ•ˆæ€§æ£€æŸ¥
    guard location.coordinate.isValid else { return false }
    
    // ç²¾åº¦æ£€æŸ¥ - è¿‡æ»¤ç²¾åº¦è¿‡ä½çš„ç‚¹
    guard location.horizontalAccuracy <= 50.0 else { return false }
    
    // æ—¶é—´æ£€æŸ¥ - è¿‡æ»¤è¿‡æ—§çš„æ•°æ®
    let timeInterval = abs(location.timestamp.timeIntervalSinceNow)
    guard timeInterval <= 10.0 else { return false }
    
    // GPSè·³è·ƒæ£€æŸ¥
    if let lastLoc = lastLocation {
        let distance = location.distance(from: lastLoc)
        let timeDiff = location.timestamp.timeIntervalSince(lastLoc.timestamp)
        let speed = distance / max(timeDiff, 0.1)
        
        // è¿‡æ»¤è¶…è¿‡åˆç†é€Ÿåº¦çš„ç‚¹ï¼ˆé˜²æ­¢GPSè·³è·ƒï¼‰
        guard speed <= 50.0 else { return false }  // 180km/hä¸Šé™
    }
    
    return true
}
```

## ğŸ—ºï¸ 7. å¤šåœ°å›¾ç±»å‹æ”¯æŒ

### 7.1 åœ°å›¾ç±»å‹å®šä¹‰

```swift
enum MapType: String, CaseIterable {
    case standard = "æ ‡å‡†"
    case satellite = "å«æ˜Ÿ" 
    case hybrid = "æ··åˆ"
    
    var mapKitType: MKMapType {
        switch self {
        case .standard: return .standard
        case .satellite: return .satellite
        case .hybrid: return .hybrid
        }
    }
    
    var icon: String {
        switch self {
        case .standard: return "map"
        case .satellite: return "globe.asia.australia"
        case .hybrid: return "map.fill"
        }
    }
}
```

### 7.2 åœ°å›¾æ§åˆ¶åŠŸèƒ½

```swift
struct MapControlButtons: View {
    @Binding var mapType: MapType
    @Binding var shouldCenterOnLocation: Bool
    
    var body: some View {
        VStack(spacing: 12) {
            // åœ°å›¾ç±»å‹åˆ‡æ¢
            Button(action: { toggleMapType() }) {
                Image(systemName: mapType.icon)
                    .font(.system(size: 20))
                    .foregroundColor(.white)
                    .frame(width: 44, height: 44)
                    .background(Color.black.opacity(0.6))
                    .clipShape(Circle())
            }
            
            // å±…ä¸­æŒ‰é’®
            Button(action: { shouldCenterOnLocation.toggle() }) {
                Image(systemName: "location.fill")
                    .font(.system(size: 20))
                    .foregroundColor(shouldCenterOnLocation ? .blue : .white)
                    .frame(width: 44, height: 44)
                    .background(Color.black.opacity(0.6))
                    .clipShape(Circle())
            }
        }
    }
    
    private func toggleMapType() {
        let allTypes = MapType.allCases
        if let currentIndex = allTypes.firstIndex(of: mapType) {
            let nextIndex = (currentIndex + 1) % allTypes.count
            mapType = allTypes[nextIndex]
        }
    }
}
```

## ğŸ’¾ 8. è½¨è¿¹æ•°æ®æŒä¹…åŒ–

### 8.1 æ•°æ®ä¿å­˜

```swift
private func saveWorkoutData() {
    let workoutSummary = WorkoutSummary(
        id: UUID(),
        workoutType: workoutType,
        workoutMode: workoutMode,
        startTime: startTime ?? Date(),
        endTime: Date(),
        duration: locationManager.duration,
        distance: distance,
        averageSpeed: locationManager.averageSpeed,
        maxSpeed: locationManager.maxSpeed,
        calories: locationManager.getCaloriesBurned(),
        routePoints: locationManager.routePoints,  // å®Œæ•´è½¨è¿¹æ•°æ®
        weatherCondition: currentWeather
    )
    
    // ä¿å­˜åˆ°æœ¬åœ°æ•°æ®åº“
    do {
        let encoded = try JSONEncoder().encode(workoutSummary)
        let key = "workout_\(workoutSummary.id.uuidString)"
        UserDefaults.standard.set(encoded, forKey: key)
        
        // åŒæ­¥åˆ°äº‘ç«¯
        syncToCloud(workoutSummary)
    } catch {
        print("âŒ ä¿å­˜è¿åŠ¨æ•°æ®å¤±è´¥: \(error)")
    }
}
```

### 8.2 æ•°æ®åŠ è½½

```swift
func loadWorkoutHistory() -> [WorkoutSummary] {
    let keys = UserDefaults.standard.dictionaryRepresentation().keys
    let workoutKeys = keys.filter { $0.hasPrefix("workout_") }
    
    var workouts: [WorkoutSummary] = []
    
    for key in workoutKeys {
        if let data = UserDefaults.standard.data(forKey: key),
           let workout = try? JSONDecoder().decode(WorkoutSummary.self, from: data) {
            workouts.append(workout)
        }
    }
    
    return workouts.sorted { $0.startTime > $1.startTime }
}
```

## ğŸ“± 9. å®æ—¶è½¨è¿¹æ˜¾ç¤º

### 9.1 è¿åŠ¨ç•Œé¢é›†æˆ

```swift
struct WorkoutLiveView: View {
    @ObservedObject private var locationManager = AppleMapService.shared
    @State private var mapType: MapType = .standard
    @State private var shouldCenterOnLocation = true
    
    var body: some View {
        ZStack {
            // åœ°å›¾è§†å›¾
            AppleMapView(
                zoomLevel: 17.0,
                showUserLocation: false,
                mapType: mapType.mapKitType,
                shouldCenterOnLocation: $shouldCenterOnLocation,
                mapRegion: $mapRegion,
                routePoints: locationManager.routePoints,  // å®æ—¶è½¨è¿¹ç‚¹
                currentLocation: locationManager.currentLocation
            )
            .ignoresSafeArea()
            
            // åœ°å›¾æ§åˆ¶æŒ‰é’®
            VStack {
                HStack {
                    Spacer()
                    MapControlButtons(
                        mapType: $mapType,
                        shouldCenterOnLocation: $shouldCenterOnLocation
                    )
                    .padding(.trailing, 16)
                }
                Spacer()
            }
            
            // è¿åŠ¨æ•°æ®é¢æ¿
            VStack {
                Spacer()
                WorkoutDataPanel(
                    distance: locationManager.mapBasedDistance,
                    duration: locationManager.duration,
                    pace: locationManager.getCurrentPace(),
                    speed: locationManager.currentSpeed
                )
                .padding(.bottom, 100)
            }
        }
    }
}
```

## ğŸ¯ 10. æŠ€æœ¯ç‰¹è‰²ä¸ä¼˜åŠ¿

### âœ¨ æ ¸å¿ƒä¼˜åŠ¿

1. **é«˜ç²¾åº¦å®šä½**
   - ä½¿ç”¨ `kCLLocationAccuracyBestForNavigation` å¯¼èˆªçº§ç²¾åº¦
   - 1ç±³è·ç¦»è¿‡æ»¤ï¼Œç¡®ä¿è½¨è¿¹ç²¾ç¡®åº¦
   - è¿åŠ¨æ¨¡å¼ä¼˜åŒ–ï¼Œæå‡GPSæ€§èƒ½

2. **åæ ‡ç³»è½¬æ¢**
   - è‡ªåŠ¨å¤„ç†WGS84â†’GCJ02è½¬æ¢
   - è§£å†³ä¸­å›½åœ°åŒºGPSåç§»é—®é¢˜
   - æµ·å¤–åœ°åŒºè‡ªåŠ¨è¯†åˆ«ï¼Œæ— éœ€è½¬æ¢

3. **å¼‚å¸¸å€¼è¿‡æ»¤**
   - å¤šé‡è¿‡æ»¤æœºåˆ¶é˜²æ­¢GPSè·³è·ƒ
   - é€Ÿåº¦é˜ˆå€¼æ£€æŸ¥ï¼ˆ50km/hä¸Šé™ï¼‰
   - æ—¶é—´å’Œè·ç¦»æœ€å°é˜ˆå€¼éªŒè¯
   - ç²¾åº¦æ£€æŸ¥è¿‡æ»¤ä½è´¨é‡æ•°æ®

4. **å†…å­˜ä¼˜åŒ–**
   - æ™ºèƒ½è½¨è¿¹ç‚¹ç®¡ç†ï¼ˆæœ€å¤§5000ç‚¹ï¼‰
   - å†…å­˜è­¦å‘Šè‡ªåŠ¨æ¸…ç†æœºåˆ¶
   - åˆ†å±‚æ•°æ®å­˜å‚¨ç­–ç•¥
   - è‡ªåŠ¨åƒåœ¾å›æ”¶ä¼˜åŒ–

5. **å®æ—¶æ¸²æŸ“**
   - ç´¯ç§¯å¼è½¨è¿¹ç»˜åˆ¶
   - æµç•…çš„è§†è§‰ä½“éªŒ
   - å¤šåœ°å›¾ç±»å‹æ”¯æŒ
   - è‡ªé€‚åº”è§†é‡è°ƒæ•´

### ğŸ”§ æŠ€æœ¯ç‰¹è‰²

- **å¤šæ•°æ®æºèåˆ**: GPS + ä¼ æ„Ÿå™¨æ•°æ®ç»¼åˆåˆ†æ
- **æ™ºèƒ½è·¯å¾„åŒ¹é…**: æ”¯æŒé¢„è®¾è·¯çº¿è¿½è¸ª
- **å®æ—¶æ•°æ®è®¡ç®—**: é€Ÿåº¦ã€è·ç¦»ã€é…é€Ÿå®æ—¶æ›´æ–°
- **å¤šåœ°å›¾æ”¯æŒ**: æ ‡å‡†/å«æ˜Ÿ/æ··åˆåœ°å›¾åˆ‡æ¢
- **æ•°æ®æŒä¹…åŒ–**: å®Œæ•´è½¨è¿¹æ•°æ®ä¿å­˜ä¸æ¢å¤
- **åå°è¿½è¸ª**: æ”¯æŒåå°GPSå®šä½
- **æƒé™ç®¡ç†**: å®Œå–„çš„å®šä½æƒé™å¤„ç†

## ğŸ“Š æ€§èƒ½æŒ‡æ ‡

- **å®šä½ç²¾åº¦**: Â±1-3ç±³ï¼ˆå¼€é˜”åœ°å¸¦ï¼‰
- **æ›´æ–°é¢‘ç‡**: 1ç§’/æ¬¡ï¼ˆè¿åŠ¨ä¸­ï¼‰
- **å†…å­˜å ç”¨**: <50MBï¼ˆ5000è½¨è¿¹ç‚¹ï¼‰
- **ç”µæ± ä¼˜åŒ–**: è¿åŠ¨æ¨¡å¼ä¼˜åŒ–ï¼Œé™ä½åŠŸè€—
- **æ•°æ®å‹ç¼©**: JSONæ ¼å¼ï¼Œå¹³å‡1KB/è½¨è¿¹ç‚¹

## ğŸ”® æœªæ¥ä¼˜åŒ–æ–¹å‘

1. **AIè½¨è¿¹ä¼˜åŒ–**: ä½¿ç”¨æœºå™¨å­¦ä¹ ä¼˜åŒ–è½¨è¿¹å¹³æ»‘åº¦
2. **ç¦»çº¿åœ°å›¾**: æ”¯æŒç¦»çº¿åœ°å›¾è½¨è¿¹è®°å½•
3. **ç¤¾äº¤åˆ†äº«**: è½¨è¿¹åˆ†äº«ä¸å¯¹æ¯”åŠŸèƒ½
4. **æ•°æ®åˆ†æ**: æ›´æ·±å…¥çš„è½¨è¿¹æ•°æ®åˆ†æ
5. **å¤šè®¾å¤‡åŒæ­¥**: è·¨è®¾å¤‡è½¨è¿¹æ•°æ®åŒæ­¥

---

*æœ¬æ–‡æ¡£è¯¦ç»†ä»‹ç»äº†é’ç¦¾è®¡åˆ’è¿åŠ¨åº”ç”¨è½¨è¿¹åŠŸèƒ½çš„å®Œæ•´æŠ€æœ¯å®ç°ï¼Œæ¶µç›–äº†ä»GPSå®šä½åˆ°æ•°æ®å¯è§†åŒ–çš„å…¨æµç¨‹æŠ€æœ¯æ–¹æ¡ˆã€‚*
