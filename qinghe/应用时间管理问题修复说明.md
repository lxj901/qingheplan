# 青禾计划 iOS 应用时间管理问题修复说明

## 问题描述

用户反馈的主要问题：
1. **时间无限循环重复**：应用管理的时间到了之后还会重新无限循环重复
2. **自律时间没有真正减少**：今日自律时间并没有随着时间的减少而真正的减去
3. **应用限制可能没有生效**：需要检查应用列表的应用打开限制权限后是否真正的限制了这个应用

## 问题分析

### 1. 时间无限循环重复的根本原因

**问题位置**：`SelfDisciplineCountdownManager.swift` 中的状态恢复逻辑

**原因**：
- 当应用重新启动或从后台恢复时，倒计时管理器会尝试恢复之前的倒计时状态
- 但没有检查是否跨天，导致前一天的倒计时状态在新的一天被错误恢复
- 这导致时间看起来在"无限循环"

**修复方案**：
```swift
// 在 loadSavedState() 方法中添加跨天检查
if !calendar.isDate(savedDate, inSameDayAs: today) {
    print("⏰ 倒计时管理器：检测到跨天，清除旧的倒计时状态")
    clearSavedState()
    return
}
```

### 2. 自律时间没有真正减少的问题

**问题位置**：`AppUsageManager.swift` 中缺少应用使用时间与自律时间的联动机制

**原因**：
- 自律时间是一个固定值，没有随着应用使用时间的增加而减少
- 应用使用时间和自律时间是分开管理的，缺乏实时联动
- 没有监控机制来跟踪应用的实际使用情况

**修复方案**：
1. **添加应用使用记录方法**：
```swift
func recordAppUsage(appName: String, usageTime: TimeInterval) {
    // 保存应用使用时间
    let currentUsedTime = getTodayUsedTime(for: appName) ?? 0
    let newUsedTime = currentUsedTime + usageTime
    saveTodayUsedTime(for: appName, usedTime: newUsedTime)
    
    // 从倒计时中扣除时间
    if countdownManager.isCountingDown {
        let usageSeconds = Int(usageTime)
        if countdownManager.remainingTimeInSeconds > usageSeconds {
            countdownManager.remainingTimeInSeconds -= usageSeconds
        } else {
            countdownManager.remainingTimeInSeconds = 0
        }
    }
}
```

2. **添加应用使用监控**：
```swift
func startMonitoringAppUsage() {
    Timer.scheduledTimer(withTimeInterval: 60.0, repeats: true) { [weak self] _ in
        Task { @MainActor in
            await self?.checkAndUpdateAppUsage()
        }
    }
}
```

### 3. 应用限制没有真正生效的问题

**问题位置**：`AppRestrictionManager.swift` 中的应用限制逻辑

**原因**：
- `ManagedSettings` 的配置可能不够完善
- 缺少有效的 `ApplicationToken` 来实现真正的应用限制
- 应用选择和限制的时机不当

**修复方案**：
1. **改进应用选择逻辑**：
```swift
func applySelection(appsAndCategories selection: FamilyActivitySelection) async {
    // 保存选择的应用，用于后续限制
    selectedApplications = selection.applications
    
    // 暂时不直接阻止应用，而是等待自律时间耗尽时再阻止
    print("📱 应用将在自律时间耗尽时被限制")
}
```

2. **添加专门的锁定方法**：
```swift
func lockSelectedApplications() async {
    await lockApplications(selectedApplications)
}
```

## 修复内容总结

### 1. SelfDisciplineCountdownManager.swift
- ✅ 添加跨天检查，防止时间无限循环
- ✅ 添加 `resetDailyCountdown()` 方法用于每日重置

### 2. AppUsageManager.swift
- ✅ 添加 `recordAppUsage()` 方法实现时间联动
- ✅ 添加 `startMonitoringAppUsage()` 监控应用使用
- ✅ 添加 `checkAndUpdateAppUsage()` 检查使用变化
- ✅ 在初始化时启动监控

### 3. AppRestrictionManager.swift
- ✅ 改进应用选择和限制逻辑
- ✅ 添加 `selectedApplications` 存储用户选择
- ✅ 添加 `lockSelectedApplications()` 专门锁定方法

## 技术实现细节

### 时间管理机制
1. **倒计时状态持久化**：使用 UserDefaults 保存倒计时状态
2. **跨天检查**：比较保存时间和当前时间是否在同一天
3. **实时监控**：每分钟检查一次应用使用情况
4. **时间联动**：应用使用时间直接从倒计时中扣除

### 应用限制机制
1. **权限检查**：确保有 Screen Time 权限
2. **应用选择**：通过 FamilyActivityPicker 选择要限制的应用
3. **延迟限制**：在自律时间耗尽时才真正限制应用
4. **ManagedSettings**：使用系统级别的应用限制

## 测试建议

1. **跨天测试**：设置倒计时后关闭应用，第二天重新打开检查状态
2. **时间扣除测试**：使用被管理的应用，观察自律时间是否正确减少
3. **应用限制测试**：自律时间耗尽后检查应用是否被真正限制
4. **权限测试**：确保 Screen Time 权限正确授予和使用

## 注意事项

1. **权限依赖**：应用限制功能依赖 Screen Time 权限
2. **系统限制**：iOS 沙盒环境限制了某些应用监控功能
3. **性能考虑**：监控频率设置为每分钟一次，平衡准确性和性能
4. **用户体验**：应用限制在自律时间耗尽时才生效，避免突然中断

## 编译状态

✅ **项目编译成功** - 所有修复已通过编译验证
