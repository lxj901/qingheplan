# 青禾计划 iOS 应用后台前台状态恢复问题修复说明

## 问题描述

用户反馈的问题：
1. **剩余时间变成初始值**：退出后台再次进入时，剩余时间又变成了初始值
2. **限制的app按钮状态改变**：之前限制的app按钮状态也变了

## 问题分析

### 1. 剩余时间变成初始值的根本原因

**问题位置**：`SelfDisciplineCountdownManager.swift` 中的前台恢复逻辑

**原因分析**：
- 应用进入前台时，`loadSavedState()` 方法被调用
- 但该方法可能没有正确计算经过的时间
- 或者在状态恢复时使用了错误的时间基准

**具体问题**：
1. `saveCurrentState()` 保存的时间戳可能不准确
2. `loadSavedState()` 计算经过时间的逻辑有误
3. 缺少详细的调试日志来跟踪状态变化

### 2. 限制的app按钮状态改变的根本原因

**问题位置**：`AppRestrictionManager.swift` 中的状态持久化

**原因分析**：
- `AppRestrictionManager` 在初始化时没有加载保存的限制状态
- 应用生命周期事件没有正确处理状态保存和恢复
- `activeRestrictions` 字典在应用重启后丢失

## 修复方案

### 1. 修复 SelfDisciplineCountdownManager 状态恢复

#### 1.1 改进状态保存逻辑
```swift
private func saveCurrentState() {
    let currentTime = Date().timeIntervalSince1970
    userDefaults.set(remainingTimeInSeconds, forKey: remainingTimeKey)
    userDefaults.set(initialTimeInSeconds, forKey: initialTimeKey)
    userDefaults.set(isCountingDown, forKey: isCountingDownKey)
    userDefaults.set(currentTime, forKey: startTimeKey) // 使用当前时间作为基准
    userDefaults.synchronize()
    
    print("⏰ 保存状态 - 剩余时间=\(remainingTimeInSeconds)秒, 初始时间=\(initialTimeInSeconds)秒, 倒计时中=\(isCountingDown), 保存时间=\(currentTime)")
}
```

#### 1.2 重写前台恢复逻辑
```swift
/// 处理应用进入前台时的状态恢复
private func handleForegroundRestore() {
    let savedRemainingTime = userDefaults.integer(forKey: remainingTimeKey)
    let savedInitialTime = userDefaults.integer(forKey: initialTimeKey)
    let savedIsCountingDown = userDefaults.bool(forKey: isCountingDownKey)
    let savedStartTime = userDefaults.double(forKey: startTimeKey)

    print("⏰ 前台恢复 - 保存的状态：剩余时间=\(savedRemainingTime)秒, 初始时间=\(savedInitialTime)秒, 倒计时中=\(savedIsCountingDown), 开始时间=\(savedStartTime)")

    // 检查是否有有效的倒计时状态
    guard savedIsCountingDown && savedRemainingTime > 0 && savedStartTime > 0 else {
        print("⏰ 前台恢复 - 没有有效的倒计时状态")
        return
    }

    // 检查是否跨天
    let savedDate = Date(timeIntervalSince1970: savedStartTime)
    let today = Date()
    let calendar = Calendar.current

    if !calendar.isDate(savedDate, inSameDayAs: today) {
        print("⏰ 前台恢复 - 检测到跨天，清除旧的倒计时状态")
        clearSavedState()
        return
    }

    // 计算经过的时间
    let currentTime = Date().timeIntervalSince1970
    let elapsedTime = Int(currentTime - savedStartTime)
    let adjustedRemainingTime = max(0, savedRemainingTime - elapsedTime)

    print("⏰ 前台恢复 - 经过时间=\(elapsedTime)秒, 调整后剩余时间=\(adjustedRemainingTime)秒")

    if adjustedRemainingTime > 0 {
        // 恢复倒计时状态，使用调整后的剩余时间
        initialTimeInSeconds = savedInitialTime
        remainingTimeInSeconds = adjustedRemainingTime // 关键：使用调整后的时间
        isCountingDown = true
        isAppsLocked = false

        // 重新开始定时器
        startTimer()

        print("⏰ 前台恢复 - 成功恢复倒计时状态，剩余 \(adjustedRemainingTime) 秒")
    } else {
        // 时间已经耗尽
        print("⏰ 前台恢复 - 时间已耗尽，触发应用锁定")
        handleTimeExpired()
    }
}
```

#### 1.3 修改前台通知处理
```swift
NotificationCenter.default.publisher(for: UIApplication.willEnterForegroundNotification)
    .sink { [weak self] _ in
        print("⏰ 倒计时管理器：应用进入前台，检查并恢复状态")
        self?.handleForegroundRestore() // 使用新的恢复方法
    }
    .store(in: &cancellables)
```

### 2. 修复 AppRestrictionManager 状态持久化

#### 2.1 在初始化时加载状态
```swift
private init() {
    checkAuthorizationStatus()
    loadRestrictions() // ✅ 启动时加载保存的限制状态
    setupNotifications() // ✅ 设置应用生命周期通知
}
```

#### 2.2 添加应用生命周期通知处理
```swift
private func setupNotifications() {
    // 监听应用进入后台
    NotificationCenter.default.addObserver(
        forName: UIApplication.didEnterBackgroundNotification,
        object: nil,
        queue: .main
    ) { [weak self] _ in
        Task { @MainActor in
            self?.saveRestrictions()
            print("📱 AppRestrictionManager: 应用进入后台，保存限制状态")
        }
    }
    
    // 监听应用进入前台
    NotificationCenter.default.addObserver(
        forName: UIApplication.willEnterForegroundNotification,
        object: nil,
        queue: .main
    ) { [weak self] _ in
        Task { @MainActor in
            self?.loadRestrictions()
            print("📱 AppRestrictionManager: 应用进入前台，加载限制状态")
        }
    }
}
```

## 修复效果

### 1. 剩余时间正确恢复
- ✅ 应用进入前台时，正确计算经过的时间
- ✅ 剩余时间 = 保存的剩余时间 - 经过的时间
- ✅ 不会重置为初始值
- ✅ 添加详细日志便于调试

### 2. 应用限制状态正确恢复
- ✅ 应用启动时自动加载保存的限制状态
- ✅ 进入后台时自动保存当前状态
- ✅ 进入前台时重新加载状态
- ✅ 按钮状态与实际限制状态保持一致

### 3. 跨天处理
- ✅ 检测跨天情况，自动清除旧的倒计时状态
- ✅ 防止前一天的状态影响新的一天

## 技术实现要点

### 1. 时间计算精度
- 使用 `Date().timeIntervalSince1970` 获取精确的时间戳
- 计算经过时间：`当前时间 - 保存时间`
- 调整剩余时间：`保存的剩余时间 - 经过时间`

### 2. 状态同步
- 使用 `@MainActor` 确保 UI 更新在主线程
- 使用 `Task` 包装异步操作
- 及时调用 `userDefaults.synchronize()` 确保数据写入

### 3. 调试支持
- 添加详细的 print 日志
- 记录关键状态变化
- 便于问题排查和验证修复效果

## 测试建议

1. **后台前台切换测试**：
   - 开始倒计时后切换到后台
   - 等待一段时间后回到前台
   - 验证剩余时间是否正确减少

2. **应用限制状态测试**：
   - 设置应用限制后切换到后台
   - 重新进入应用
   - 验证限制按钮状态是否保持

3. **跨天测试**：
   - 设置倒计时后关闭应用
   - 第二天重新打开应用
   - 验证是否正确清除旧状态

4. **长时间后台测试**：
   - 设置较短的倒计时（如5分钟）
   - 切换到后台超过倒计时时间
   - 回到前台验证是否正确触发时间耗尽

## 编译状态

✅ **项目编译成功** - 所有修复已通过编译验证

这些修复确保了应用在后台前台切换时能够正确保持和恢复状态，解决了用户反馈的问题。
