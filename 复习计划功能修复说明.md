# 复习计划功能修复说明

## 修复日期
2025-10-20

## 问题描述

### 问题 1: 复习计划标记显示在所有断句上
**现象**: 在一个句段添加复习计划后，其他句段也跟着显示复习计划的 UI 标记

**原因**:
- 与之前的高亮/笔记问题完全相同
- `reviewPlanMarks` 使用全局数组 `[ReviewPlanMark]`
- 所有 section 共享同一个复习计划标记数组

### 问题 2: 第二次打开页面后复习计划 UI 消失
**现象**: 用户添加复习计划后关闭页面，重新打开后看不到复习计划的标记了

**原因**:
- 没有从 API 加载复习计划数据
- 复习计划只保存到服务器，但没有还原到 UI

## 解决方案

### 1. 修改数据结构（按 sectionId 隔离）

**修改前**:
```swift
@State private var reviewPlanMarks: [ReviewPlanMark] = []  // ❌ 全局数组
```

**修改后**:
```swift
@State private var reviewPlanMarks: [String: [ReviewPlanMark]] = [:]  // ✅ 按 sectionId 存储
```

### 2. 修改 createOriginalTextView 方法

为每个 section 创建独立的复习计划标记绑定:

```swift
// 获取当前 section 的复习计划标记
let sectionReviewMarks = reviewPlanMarks[section.id] ?? []

return SelectableTextView(
    attributedText: attributedText,
    coloredHighlights: sectionHighlights,
    notes: sectionNotes,
    reviewPlanMarks: sectionReviewMarks,  // ✅ 使用独立数组
    ...
)
```

### 3. 修改 createReviewPlan 方法

**修改前**:
```swift
// 创建复习计划标记
let mark = ReviewPlanMark(...)
reviewPlanMarks.append(mark)  // ❌ 添加到全局数组
```

**修改后**:
```swift
// 创建复习计划标记，添加到对应的 section
let mark = ReviewPlanMark(...)

// 添加到对应 sectionId 的数组中
var marks = reviewPlanMarks[sectionId] ?? []
marks.append(mark)
reviewPlanMarks[sectionId] = marks  // ✅ 按 sectionId 存储
```

### 4. 添加复习计划 API 数据模型

在 `ClassicsAPIService.swift` 中添加:

```swift
/// 复习计划
struct ClassicsReviewPlan: Codable, Identifiable {
    let id: String
    let sectionId: String
    let bookId: String
    let chapterId: String
    let original: String?
    let nextReviewAt: String
    let reviewCount: Int
    let interval: Int?
}
```

### 5. 添加获取复习列表的 API 方法

```swift
/// 获取复习列表
func getReviewList(userId: Int, dueOnly: Bool = true) async throws -> [ClassicsReviewPlan] {
    var urlString = "\(baseURL)/review/list?userId=\(userId)&dueOnly=\(dueOnly)"

    // ... API 调用逻辑

    return reviewList
}
```

### 6. 添加加载复习计划数据的方法

在 `ClassicsReadingView.swift` 中添加:

```swift
/// 加载复习计划数据
private func loadReviewPlans(bookId: String) async {
    guard let userId = AuthManager.shared.getCurrentUserId() else {
        return
    }

    do {
        // 获取所有复习计划（不仅仅是到期的）
        let plans = try await ClassicsAPIService.shared.getReviewList(userId: userId, dueOnly: false)

        await MainActor.run {
            // 过滤当前书籍的复习计划，并按 sectionId 分组
            for plan in plans where plan.bookId == bookId {
                let sectionId = plan.sectionId

                // 转换为 ReviewPlanMark 格式
                let mark = ReviewPlanMark(
                    id: plan.id,
                    text: plan.original ?? "",
                    range: NSRange(location: 0, length: plan.original?.count ?? 0),
                    nextReviewAt: plan.nextReviewAt,
                    reviewCount: plan.reviewCount,
                    isCompleted: false
                )

                // 添加到对应 sectionId 的数组中
                var marks = reviewPlanMarks[sectionId] ?? []
                marks.append(mark)
                reviewPlanMarks[sectionId] = marks
            }
        }
    } catch {
        print("⚠️ 加载复习计划失败: \(error)")
    }
}
```

### 7. 在初始化时调用加载方法

```swift
private func initializeData() async {
    if let bookId = bookId {
        await loadBookDetail(bookId: bookId)
        await loadUserProgress(bookId: bookId)
        await loadUserMarks(bookId: bookId)        // 加载标记数据
        await loadReviewPlans(bookId: bookId)      // ✅ 加载复习计划数据

        // ...
    }
}
```

## 数据流程

### 创建复习计划流程
```
用户操作 → 调用 API (POST /review/plan) →
保存到服务器 → 更新本地状态 (reviewPlanMarks[sectionId]) →
UI 显示复习标记
```

### 加载复习计划流程
```
页面加载 → 调用 API (GET /review/list) →
获取所有复习计划 → 过滤当前书籍 →
按 sectionId 分组 → 转换为 ReviewPlanMark →
更新 reviewPlanMarks 字典 → UI 显示
```

## API 接口

### 获取复习列表
```http
GET /api/v1/classics/review/list?userId=123&dueOnly=false
Authorization: Bearer {token}
```

**响应示例**:
```json
{
  "code": 0,
  "message": "success",
  "data": [
    {
      "id": "uuid",
      "sectionId": "section-uuid",
      "bookId": "lunyu",
      "chapterId": "xueer",
      "original": "子曰：「学而时习之...",
      "nextReviewAt": "2024-10-19T10:00:00.000Z",
      "reviewCount": 3,
      "interval": 7
    }
  ]
}
```

**参数说明**:
- `userId`: 用户ID（必填）
- `dueOnly`: 只获取到期的复习项（可选，默认 true）
  - `true`: 只返回到期需要复习的项
  - `false`: 返回所有复习计划（包括未到期的）

## 修改文件清单

### ClassicsAPIService.swift

1. **第 108-118 行**: 添加 `ClassicsReviewPlan` 数据模型
2. **第 450-484 行**: 添加 `getReviewList` API 方法

### ClassicsReadingView.swift

1. **第 68 行**: 修改 `reviewPlanMarks` 数据结构为字典
2. **第 900-912 行**: 修改 `createOriginalTextView`，使用独立的复习标记
3. **第 1484-1521 行**: 添加 `loadReviewPlans` 方法
4. **第 1650-1653 行**: 修改 `createReviewPlan`，按 sectionId 存储标记
5. **第 1728 行**: 在初始化时调用 `loadReviewPlans`

## 对比总结：三种标记的数据结构

### 修复前后对比

| 标记类型 | 修复前（全局） | 修复后（按 sectionId） |
|---------|--------------|---------------------|
| 高亮 | `[ColoredHighlight]` | `[String: [ColoredHighlight]]` |
| 笔记 | `[AnnotatedNote]` | `[String: [AnnotatedNote]]` |
| 复习计划 | `[ReviewPlanMark]` | `[String: [ReviewPlanMark]]` |

### 统一的解决思路

所有标记功能都遵循相同的模式：
1. ✅ 数据结构改为字典：`[String: [标记类型]]`
2. ✅ 创建时按 sectionId 存储
3. ✅ 渲染时使用独立的数组
4. ✅ 加载时从 API 获取并转换为 UI 状态

## 测试检查清单

### 基本功能测试
- [ ] 在第 1 个句段添加复习计划 → 只在第 1 个句段显示标记
- [ ] 在第 2 个句段添加复习计划 → 只在第 2 个句段显示标记
- [ ] 验证两个复习计划标记互不影响

### 持久化测试
- [ ] 添加复习计划 → 退出页面 → 重新进入
- [ ] 验证复习计划标记仍然存在
- [ ] 验证标记显示在正确的句段上

### 数据同步测试
- [ ] 在设备 A 添加复习计划
- [ ] 在设备 B 打开相同页面
- [ ] 验证复习计划正确同步显示

### API 测试
- [ ] 查看控制台日志确认 API 调用成功
- [ ] 验证 `dueOnly=false` 返回所有复习计划
- [ ] 验证复习计划数据正确转换为 UI 格式

## 预期效果

### 修复后的正确行为

1. **独立标记**:
   - 第 1 句段添加复习计划 → 只在第 1 句段显示 ⏰ 标记
   - 第 2 句段添加复习计划 → 只在第 2 句段显示 ⏰ 标记
   - 两个标记完全独立，互不影响

2. **数据持久化**:
   - 添加复习计划 → 保存到服务器
   - 重新打开页面 → 自动从服务器加载
   - UI 正确显示复习计划标记

3. **多设备同步**:
   - 设备 A 添加复习计划
   - 设备 B 打开页面自动同步
   - 所有设备显示一致

## 注意事项

1. **API 参数**: `dueOnly=false` 获取所有复习计划，确保加载完整数据

2. **数据过滤**: 在 `loadReviewPlans` 中过滤 `plan.bookId == bookId`，只加载当前书籍的复习计划

3. **性能考虑**: 如果用户有大量复习计划，建议：
   - 只加载当前章节的复习计划
   - 使用分页或按需加载
   - 添加本地缓存

4. **到期提醒**:
   - 目前加载所有复习计划（包括未到期的）
   - 可以根据 `nextReviewAt` 字段高亮显示到期的复习项
   - 考虑添加推送通知提醒用户复习

## 后续优化建议

### 短期优化
1. ✅ 添加复习计划的删除功能
2. ✅ 高亮显示到期的复习项
3. ✅ 添加复习完成的交互（调用 `/review/complete` 接口）

### 中期优化
1. 🔄 复习提醒推送通知
2. 🔄 复习统计和进度展示
3. 🔄 自定义复习间隔设置

### 长期优化
1. 📋 基于艾宾浩斯遗忘曲线的智能复习推荐
2. 📋 复习效果分析和调整
3. 📋 跨书籍的复习计划管理

## 版本信息

- **修复版本**: 1.2.0
- **修复日期**: 2025-10-20
- **相关问题**:
  - 复习计划标记显示在所有句段
  - 复习计划数据第二次打开不显示
- **影响范围**:
  - ClassicsAPIService.swift
  - ClassicsReadingView.swift
