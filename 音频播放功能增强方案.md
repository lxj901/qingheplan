# 音频播放功能增强实现方案

## 需求概述

### 当前问题
1. **音色固定**: 只显示默认的墨讲师，无法选择其他音色
2. **无后台播放**: 用户退出听书页面后，音频停止播放
3. **缺少高级功能**: 没有倍速播放和定时关闭功能

### 目标功能
1. ✅ 音色选择 - 显示所有可用音色，用户可自由切换
2. ✅ 后台播放 - 退出页面后继续播放，添加悬浮球控制
3. ✅ 倍速播放 - 0.5x ~ 2.0x 倍速选择
4. ✅ 定时关闭 - 15/30/45/60 分钟或播放完当前章节

## 技术架构

### 1. 全局音频管理器

创建 `GlobalAudioPlayer.swift` 作为单例管理器：

```swift
class GlobalAudioPlayer: ObservableObject {
    static let shared = GlobalAudioPlayer()

    // 播放器
    @Published var player: AVPlayer?
    @Published var isPlaying: Bool = false
    @Published var currentTime: Double = 0
    @Published var duration: Double = 0

    // 播放列表
    @Published var playlist: [PlaylistItem] = []
    @Published var currentIndex: Int = 0

    // 播放设置
    @Published var playbackRate: Float = 1.0        // 倍速
    @Published var selectedVoice: String = "Elias"  // 音色
    @Published var sleepTimer: Date? = nil          // 定时关闭

    // 后台播放支持
    private var timeObserver: Any?

    private init() {
        setupAudioSession()
        setupRemoteControl()
        setupNotifications()
    }

    // 音频会话配置（支持后台播放）
    func setupAudioSession() {
        do {
            try AVAudioSession.sharedInstance().setCategory(
                .playback,
                mode: .spokenAudio,
                options: []
            )
            try AVAudioSession.sharedInstance().setActive(true)
        } catch {
            print("❌ 音频会话配置失败: \(error)")
        }
    }

    // 配置锁屏控制
    func setupRemoteControl() {
        let commandCenter = MPRemoteCommandCenter.shared()

        // 播放
        commandCenter.playCommand.addTarget { [weak self] _ in
            self?.play()
            return .success
        }

        // 暂停
        commandCenter.pauseCommand.addTarget { [weak self] _ in
            self?.pause()
            return .success
        }

        // 上一曲
        commandCenter.previousTrackCommand.addTarget { [weak self] _ in
            self?.playPrevious()
            return .success
        }

        // 下一曲
        commandCenter.nextTrackCommand.addTarget { [weak self] _ in
            self?.playNext()
            return .success
        }
    }

    // 更新锁屏信息
    func updateNowPlaying(title: String, chapter: String) {
        var nowPlayingInfo = [String: Any]()
        nowPlayingInfo[MPMediaItemPropertyTitle] = title
        nowPlayingInfo[MPMediaItemPropertyArtist] = chapter
        nowPlayingInfo[MPNowPlayingInfoPropertyElapsedPlaybackTime] = currentTime
        nowPlayingInfo[MPMediaItemPropertyPlaybackDuration] = duration
        nowPlayingInfo[MPNowPlayingInfoPropertyPlaybackRate] = isPlaying ? playbackRate : 0

        MPNowPlayingInfoCenter.default().nowPlayingInfo = nowPlayingInfo
    }

    // 播放
    func play() {
        player?.play()
        player?.rate = playbackRate
        isPlaying = true
    }

    // 暂停
    func pause() {
        player?.pause()
        isPlaying = false
    }

    // 设置倍速
    func setPlaybackRate(_ rate: Float) {
        playbackRate = rate
        if isPlaying {
            player?.rate = rate
        }
    }

    // 设置定时关闭
    func setSleepTimer(minutes: Int) {
        sleepTimer = Date().addingTimeInterval(TimeInterval(minutes * 60))

        // 启动定时器检查
        Timer.scheduledTimer(withTimeInterval: 1, repeats: true) { [weak self] timer in
            guard let self = self, let sleepTimer = self.sleepTimer else {
                timer.invalidate()
                return
            }

            if Date() >= sleepTimer {
                self.pause()
                self.sleepTimer = nil
                timer.invalidate()
            }
        }
    }
}
```

### 2. 悬浮球控制组件

创建 `FloatingAudioControl.swift`：

```swift
struct FloatingAudioControl: View {
    @ObservedObject var audioPlayer = GlobalAudioPlayer.shared
    @State private var position = CGPoint(x: UIScreen.main.bounds.width - 80, y: 100)
    @State private var isExpanded = false

    var body: some View {
        ZStack {
            if isExpanded {
                // 展开的播放控制面板
                expandedControl
            } else {
                // 收起的悬浮球
                compactControl
            }
        }
        .position(position)
        .gesture(
            DragGesture()
                .onChanged { value in
                    position = value.location
                }
        )
    }

    // 收起的悬浮球
    private var compactControl: some View {
        Button(action: {
            withAnimation(.spring()) {
                isExpanded.toggle()
            }
        }) {
            ZStack {
                Circle()
                    .fill(Color.black.opacity(0.7))
                    .frame(width: 60, height: 60)
                    .shadow(radius: 4)

                Image(systemName: audioPlayer.isPlaying ? "pause.fill" : "play.fill")
                    .font(.system(size: 24))
                    .foregroundColor(.white)
            }
        }
    }

    // 展开的控制面板
    private var expandedControl: some View {
        VStack(spacing: 12) {
            // 标题
            Text(audioPlayer.playlist[safe: audioPlayer.currentIndex]?.original ?? "")
                .font(.system(size: 14, weight: .medium))
                .lineLimit(1)
                .foregroundColor(.white)

            // 播放控制
            HStack(spacing: 20) {
                // 上一曲
                Button(action: {
                    audioPlayer.playPrevious()
                }) {
                    Image(systemName: "backward.fill")
                        .font(.system(size: 20))
                        .foregroundColor(.white)
                }

                // 播放/暂停
                Button(action: {
                    if audioPlayer.isPlaying {
                        audioPlayer.pause()
                    } else {
                        audioPlayer.play()
                    }
                }) {
                    Image(systemName: audioPlayer.isPlaying ? "pause.circle.fill" : "play.circle.fill")
                        .font(.system(size: 40))
                        .foregroundColor(.white)
                }

                // 下一曲
                Button(action: {
                    audioPlayer.playNext()
                }) {
                    Image(systemName: "forward.fill")
                        .font(.system(size: 20))
                        .foregroundColor(.white)
                }
            }

            // 倍速和定时
            HStack(spacing: 16) {
                // 倍速
                Menu {
                    ForEach([0.5, 0.75, 1.0, 1.25, 1.5, 2.0], id: \.self) { rate in
                        Button("\(rate, specifier: "%.2f")x") {
                            audioPlayer.setPlaybackRate(Float(rate))
                        }
                    }
                } label: {
                    Text("\(audioPlayer.playbackRate, specifier: "%.2f")x")
                        .font(.system(size: 12))
                        .foregroundColor(.white)
                        .padding(.horizontal, 8)
                        .padding(.vertical, 4)
                        .background(Color.white.opacity(0.2))
                        .cornerRadius(4)
                }

                // 定时
                Menu {
                    Button("15分钟") { audioPlayer.setSleepTimer(minutes: 15) }
                    Button("30分钟") { audioPlayer.setSleepTimer(minutes: 30) }
                    Button("45分钟") { audioPlayer.setSleepTimer(minutes: 45) }
                    Button("60分钟") { audioPlayer.setSleepTimer(minutes: 60) }
                } label: {
                    Image(systemName: "moon.fill")
                        .font(.system(size: 14))
                        .foregroundColor(.white)
                }
            }

            // 收起按钮
            Button(action: {
                withAnimation(.spring()) {
                    isExpanded = false
                }
            }) {
                Image(systemName: "chevron.down")
                    .font(.system(size: 12))
                    .foregroundColor(.white)
            }
        }
        .padding(16)
        .background(
            RoundedRectangle(cornerRadius: 16)
                .fill(Color.black.opacity(0.8))
                .shadow(radius: 8)
        )
        .frame(width: 200)
    }
}

// 安全下标访问
extension Array {
    subscript(safe index: Int) -> Element? {
        return indices.contains(index) ? self[index] : nil
    }
}
```

### 3. 音色选择组件

在播放页面添加音色选择：

```swift
struct VoiceSelectionSheet: View {
    @ObservedObject var audioPlayer = GlobalAudioPlayer.shared
    @State private var voices: [TTSVoice] = []
    @State private var isLoading = true
    @Binding var isPresented: Bool

    var body: some View {
        NavigationView {
            Group {
                if isLoading {
                    ProgressView("加载音色列表...")
                } else {
                    List {
                        Section(header: Text("推荐音色")) {
                            ForEach(voices.filter { $0.isRecommended }) { voice in
                                voiceRow(voice)
                            }
                        }

                        Section(header: Text("方言音色")) {
                            ForEach(voices.filter { !$0.isRecommended }) { voice in
                                voiceRow(voice)
                            }
                        }
                    }
                }
            }
            .navigationTitle("选择音色")
            .navigationBarTitleDisplayMode(.inline)
            .toolbar {
                ToolbarItem(placement: .cancellationAction) {
                    Button("取消") {
                        isPresented = false
                    }
                }
            }
        }
        .task {
            await loadVoices()
        }
    }

    private func voiceRow(_ voice: TTSVoice) -> some View {
        Button(action: {
            audioPlayer.selectedVoice = voice.voiceId
            isPresented = false
        }) {
            HStack {
                VStack(alignment: .leading, spacing: 4) {
                    Text(voice.name)
                        .font(.system(size: 16, weight: .medium))
                        .foregroundColor(.primary)

                    Text(voice.description)
                        .font(.system(size: 13))
                        .foregroundColor(.secondary)
                }

                Spacer()

                if audioPlayer.selectedVoice == voice.voiceId {
                    Image(systemName: "checkmark.circle.fill")
                        .foregroundColor(.blue)
                }
            }
        }
    }

    private func loadVoices() async {
        do {
            voices = try await ClassicsAPIService.shared.getTTSVoices()
            isLoading = false
        } catch {
            print("❌ 加载音色失败: \(error)")
            isLoading = false
        }
    }
}
```

## 实现步骤

### 第 1 步: 创建全局音频管理器
1. 创建 `GlobalAudioPlayer.swift`
2. 实现基础的播放控制
3. 配置音频会话支持后台播放
4. 实现锁屏控制

### 第 2 步: 实现悬浮球控制
1. 创建 `FloatingAudioControl.swift`
2. 实现拖拽功能
3. 实现展开/收起动画
4. 添加到主视图

### 第 3 步: 实现音色选择
1. 创建音色选择 Sheet
2. 从 API 加载音色列表
3. 实现音色切换功能
4. 保存用户偏好

### 第 4 步: 实现倍速播放
1. 添加倍速选择 UI
2. 实现 AVPlayer 的 rate 控制
3. 保存用户倍速偏好

### 第 5 步: 实现定时关闭
1. 添加定时设置 UI
2. 实现定时器逻辑
3. 定时到达后自动暂停

### 第 6 步: 集成到现有页面
1. 在 `qingheApp.swift` 中添加悬浮球
2. 修改 `ClassicsReadingView` 使用全局播放器
3. 添加音色选择按钮
4. 添加播放控制 UI

## 配置需求

### Info.plist 配置

需要添加后台播放权限：

```xml
<key>UIBackgroundModes</key>
<array>
    <string>audio</string>
</array>

<key>NSAppleMusicUsageDescription</key>
<string>用于播放国学经典音频</string>
```

### 权限说明
- `audio` 后台模式：允许应用在后台播放音频
- `NSAppleMusicUsageDescription`：iOS 要求的权限说明

## 用户体验优化

### 1. 平滑过渡
- 音色切换时：淡入淡出效果
- 倍速切换时：平滑调整，避免卡顿
- 定时关闭时：渐弱音量

### 2. 状态持久化
- 记住用户选择的音色
- 记住用户的倍速偏好
- 记住播放位置

### 3. 错误处理
- 网络错误时的重试机制
- 音频加载失败的提示
- 后台播放中断的恢复

## 测试计划

### 功能测试
- [ ] 选择不同音色播放
- [ ] 切换倍速播放
- [ ] 设置定时关闭
- [ ] 退出页面后继续播放
- [ ] 悬浮球控制播放

### 系统测试
- [ ] 锁屏控制中心显示
- [ ] 蓝牙耳机控制
- [ ] 来电时自动暂停
- [ ] 其他应用播放时的行为

### 性能测试
- [ ] 长时间播放的稳定性
- [ ] 内存占用
- [ ] 电池消耗

## 预期效果

### 用户场景 1: 听书入睡
```
用户打开听书页面 →
选择舒缓的女声音色 →
设置 0.75x 倍速 →
设置 30 分钟定时关闭 →
退出应用（音频继续播放）→
30 分钟后自动暂停
```

### 用户场景 2: 通勤学习
```
用户开始播放 →
退出应用查看其他信息 →
通过悬浮球控制播放 →
遇到难点降低倍速到 0.75x →
重新听一遍
```

### 用户场景 3: 快速浏览
```
用户想快速过一遍内容 →
设置 1.5x 倍速 →
使用悬浮球快速切换章节 →
遇到重点降回 1.0x 仔细听
```

## 技术难点和解决方案

### 难点 1: 后台播放权限
**解决**: 配置 `UIBackgroundModes` 和正确的音频会话

### 难点 2: 锁屏控制
**解决**: 使用 `MPRemoteCommandCenter` 和 `MPNowPlayingInfoCenter`

### 难点 3: 悬浮球的位置保存
**解决**: 使用 `UserDefaults` 保存位置，下次启动时恢复

### 难点 4: 倍速播放的音质
**解决**: AVPlayer 的 rate 调整会自动保持音质，无需特殊处理

### 难点 5: 定时关闭的精确性
**解决**: 使用 Timer 每秒检查一次，误差控制在 1 秒以内

## 后续优化

### 短期
- 添加播放进度保存
- 添加播放历史记录
- 优化音色切换的流畅度

### 中期
- 支持自定义定时时间
- 支持播放完当前句段/章节后停止
- 添加睡眠模式（渐弱音量）

### 长期
- AI 推荐合适的音色
- 根据时间自动调整倍速
- 多设备播放进度同步

## 预计工作量

- 全局音频管理器：2-3 小时
- 悬浮球控制：1-2 小时
- 音色选择：1 小时
- 倍速和定时：1 小时
- 集成和测试：2-3 小时

**总计**: 7-10 小时

## 版本规划

- **v1.4.0**: 音色选择 + 倍速播放
- **v1.4.1**: 定时关闭功能
- **v1.5.0**: 后台播放 + 悬浮球控制
- **v1.5.1**: 锁屏控制优化

## 总结

音频播放功能的增强将大大提升用户体验，特别是对于：
- 💤 **睡前听书用户**: 定时关闭 + 舒缓音色
- 🚗 **通勤学习用户**: 后台播放 + 悬浮球控制
- 📚 **快速学习用户**: 倍速播放 + 音色选择

这些功能的实现将使国学经典 App 的听书体验达到市场领先水平。
